{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncDocumentImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n    this.isDeleted = false;\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\n    this.descriptor = descriptor;\n    this.descriptor.data = this.descriptor.data || {};\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'document';\n  }\n\n  get type() {\n    return 'document';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get data() {\n    return this.descriptor.data;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n  /**\n   * Update data entity with new data\n   * @private\n   */\n\n\n  _update(update) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'document_updated':\n        if (update.id <= this.lastEventId) {\n          logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\n          break;\n        }\n\n        const previousData = this.descriptor.data !== undefined ? sanitize_1.deepClone(this.descriptor.data) : null;\n        this.descriptor.last_event_id = update.id;\n        this.descriptor.revision = update.document_revision;\n        this.descriptor.date_updated = update.date_created;\n        this.descriptor.data = update.document_data;\n        this.broadcastEventToListeners('updated', {\n          data: update.document_data,\n          isLocal: false,\n          previousData\n        });\n        this.services.storage.update(this.type, this.sid, this.uniqueName, {\n          last_event_id: update.id,\n          revision: update.document_revision,\n          date_updated: update.date_created,\n          data: update.document_data\n        });\n        break;\n\n      case 'document_removed':\n        this.onRemoved(false);\n        break;\n    }\n  }\n\n  async set(value, metadataUpdates) {\n    const input = metadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));\n  }\n\n  async mutate(mutator, metadataUpdates) {\n    const input = metadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));\n  }\n\n  async update(obj, metadataUpdates) {\n    return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    const response = await this._postUpdateToServer({\n      ttl\n    });\n    this.descriptor.date_expires = response.date_expires;\n  }\n  /**\n   * @private\n   */\n\n\n  async _setUnconditionally(value, ttl) {\n    let result = await this._postUpdateToServer({\n      data: value,\n      revision: undefined,\n      ttl\n    });\n\n    this._handleSuccessfulUpdateResult(result);\n\n    return this.descriptor.data;\n  }\n  /**\n   * @private\n   */\n\n\n  async _setWithIfMatch(mutatorFunction, ttl) {\n    let data = mutatorFunction(sanitize_1.deepClone(this.descriptor.data));\n\n    if (data) {\n      let revision = this.revision;\n\n      try {\n        let result = await this._postUpdateToServer({\n          data,\n          revision,\n          ttl\n        });\n\n        this._handleSuccessfulUpdateResult(result);\n\n        return this.descriptor.data;\n      } catch (error) {\n        if (error.status === 412) {\n          await this._softSync();\n          return this._setWithIfMatch(mutatorFunction);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return this.descriptor.data;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _handleSuccessfulUpdateResult(result) {\n    // Ignore returned value if we already got a newer one\n    if (result.last_event_id <= this.descriptor.last_event_id) {\n      return;\n    }\n\n    const previousData = this.descriptor.data !== undefined ? sanitize_1.deepClone(this.descriptor.data) : null;\n    this.descriptor.revision = result.revision;\n    this.descriptor.data = result.data;\n    this.descriptor.last_event_id = result.last_event_id;\n    this.descriptor.date_expires = result.date_expires;\n    this.descriptor.date_updated = new Date(result.date_updated);\n    this.services.storage.update(this.type, this.sid, this.uniqueName, {\n      last_event_id: result.last_event_id,\n      revision: result.revision,\n      date_updated: result.date_updated,\n      data: result.data\n    });\n    this.broadcastEventToListeners('updated', {\n      data: this.descriptor.data,\n      isLocal: true,\n      previousData\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  async _postUpdateToServer(request) {\n    if (!this.isDeleted) {\n      const requestBody = {\n        data: request.data\n      };\n\n      if (request.ttl !== undefined) {\n        requestBody.ttl = request.ttl;\n      }\n\n      const ifMatch = request.revision;\n\n      try {\n        const response = await this.services.network.post(this.uri, requestBody, ifMatch);\n        return {\n          revision: response.body.revision,\n          data: request.data,\n          last_event_id: response.body.last_event_id,\n          date_updated: response.body.date_updated,\n          date_expires: response.body.date_expires\n        };\n      } catch (error) {\n        if (error.status === 404) {\n          this.onRemoved(false);\n        }\n\n        throw error;\n      }\n    } else {\n      return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n    }\n  }\n  /**\n   * Get new data from server\n   * @private\n   */\n\n\n  async _softSync() {\n    return this.services.network.get(this.uri).then(response => {\n      const event = {\n        type: 'document_updated',\n        id: response.body.last_event_id,\n        document_revision: response.body.revision,\n        document_data: response.body.data,\n        date_created: response.body.date_updated\n      };\n\n      this._update(event);\n\n      return this;\n    }).catch(err => {\n      if (err.status === 404) {\n        this.onRemoved(false);\n      } else {\n        logger_1.default.error(\"Can't get updates for \".concat(this.sid, \":\"), err);\n      }\n    });\n  }\n\n  onRemoved(locally) {\n    if (this.isDeleted) {\n      return;\n    }\n\n    const previousData = this.descriptor.data !== undefined ? sanitize_1.deepClone(this.descriptor.data) : null;\n    this.isDeleted = true;\n\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally,\n      previousData\n    });\n  }\n\n  async removeDocument() {\n    if (!this.isDeleted) {\n      await this.services.network.delete(this.uri);\n      this.onRemoved(true);\n    } else {\n      return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n    }\n  }\n\n}\n\nexports.SyncDocumentImpl = SyncDocumentImpl;\n/**\n * @class\n * @alias Document\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\n * Information about rate limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.\n * @property {String} sid The immutable identifier of this document, assigned by the system.\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\n * to this document during creation. Globally unique among other Documents.\n * @property {Date} dateUpdated Date when the Document was last updated.\n * @property {Object} data The contents of this document.\n *\n * @fires Document#removed\n * @fires Document#updated\n */\n\nclass SyncDocument extends closeable_1.default {\n  constructor(syncDocumentImpl) {\n    super();\n    this.syncDocumentImpl = syncDocumentImpl;\n    this.syncDocumentImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncDocumentImpl.uri;\n  }\n\n  get revision() {\n    return this.syncDocumentImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncDocumentImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncDocumentImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncDocumentImpl.type;\n  }\n\n  get type() {\n    return SyncDocumentImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncDocumentImpl.sid;\n  }\n\n  get data() {\n    return this.syncDocumentImpl.data;\n  }\n\n  get dateUpdated() {\n    return this.syncDocumentImpl.dateUpdated;\n  }\n\n  get uniqueName() {\n    return this.syncDocumentImpl.uniqueName;\n  }\n  /**\n   * Assign new contents to this document. The current data will be overwritten.\n   * @param {Object} data The new contents to assign.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @returns {Promise<Object>} A promise resolving to the new data of the document.\n   * @public\n   * @example\n   * // Say, the Document data is { name: 'John Smith', age: 34 }\n   * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\n   *   .then(function(newValue) {\n   *     // Now the Document data is { name: 'Barbara Oaks' }\n   *     console.log('Document set() successful, new data:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document set() failed', error);\n   *   });\n   */\n\n\n  async set(data, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.set(data, metadataUpdates);\n  }\n  /**\n   * Schedules a modification to this document that will apply a mutation function.\n   * @param {Document~Mutator} mutator A function that outputs a new data based on the existing data.\n   * May be called multiple times, particularly if this Document is modified concurrently by remote code.\n   * If the mutation ultimately succeeds, the Document will have made the particular transition described\n   * by this function.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\n   *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n   * @public\n   * @example\n   * var mutatorFunction = function(currentValue) {\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n   *     return currentValue;\n   * };\n   * document.mutate(mutatorFunction, { ttl: 86400 }))\n   *   .then(function(newValue) {\n   *     console.log('Document mutate() successful, new data:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document mutate() failed', error);\n   *   });\n   */\n\n\n  async mutate(mutator, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.mutate(mutator, metadataUpdates);\n  }\n  /**\n   * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\n   * This is equivalent to\n   * <pre>\n   * document.mutate(function(currentValue) {\n   *   return Object.assign(currentValue, obj));\n   * });\n   * </pre>\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @return {Promise<Object>} A promise resolving to the new data of the document.\n   * @public\n   * @example\n   * // Say, the Document data is { name: 'John Smith' }\n   * document.update({ age: 34 }, { ttl: 86400 })\n   *   .then(function(newValue) {\n   *     // Now the Document data is { name: 'John Smith', age: 34 }\n   *     console.log('Document update() successful, new data:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document update() failed', error);\n   *   });\n   */\n\n\n  async update(obj, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.update(obj, metadataUpdates);\n  }\n  /**\n   * Update the time-to-live of the document.\n   * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * document.setTtl(3600)\n   *   .then(function() {\n   *     console.log('Document setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document setTtl() failed', error);\n   *   });\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.setTtl(ttl);\n  }\n  /**\n   * Delete a document.\n   * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\n   * @public\n   * @example\n   * document.removeDocument()\n   *   .then(function() {\n   *     console.log('Document removeDocument() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document removeDocument() failed', error);\n   *   });\n   */\n\n\n  async removeDocument() {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.removeDocument();\n  }\n  /**\n   * Conclude work with the document instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this document will continue operating and receiving events normally.\n   * @public\n   * @example\n   * document.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncDocumentImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncDocument = SyncDocument;\nexports.default = SyncDocument;\n/**\n * Contains Document metadata.\n * @typedef {Object} Document#Metadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the document data.\n * @callback Document~Mutator\n * @param {Object} currentValue The current data of the document in the cloud.\n * @return {Object} The desired new data for the document or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when the document is removed, whether the remover was local or remote.\n * @event Document#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\n * @param {Object} args.previousData Contains a snapshot of the document data before removal.\n * @example\n * document.on('removed', function(args) {\n *   console.log('Document ' + document.sid + ' was removed');\n *   console.log('args.isLocal: ', args.isLocal);\n *   console.log('args.previousData: ', args.previousData);\n * });\n */\n\n/**\n * Fired when the document's contents have changed, whether the updater was local or remote.\n * @event Document#updated\n * @param {Object} args Arguments provided with the event.\n * @param {Object} args.data A snapshot of the document's new contents.\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\n * @param {Object} args.previousData Contains a snapshot of the document data before the update.\n * @example\n * document.on('updated', function(args) {\n *   console.log('Document ' + document.sid + ' was updated');\n *   console.log('args.data: ', args.data);\n *   console.log('args.isLocal: ', args.isLocal);\n *   console.log('args.previousData: ', args.previousData);\n * });\n */","map":{"version":3,"sources":["/Users/abdulkhan/Documents/waymax/Waymax/node_modules/twilio-sync/lib/syncdocument.js"],"names":["Object","defineProperty","exports","value","syncerror_1","require","sanitize_1","logger_1","entity_1","mergingqueue_1","closeable_1","SyncDocumentImpl","SyncEntity","constructor","services","descriptor","removalHandler","isDeleted","updateRequestReducer","acc","input","ttl","updateMergingQueue","MergingQueue","data","date_updated","Date","uri","url","revision","lastEventId","last_event_id","dateExpires","date_expires","type","indexName","undefined","queryString","sid","dateUpdated","uniqueName","unique_name","_update","update","date_created","id","default","trace","previousData","deepClone","document_revision","document_data","broadcastEventToListeners","isLocal","storage","onRemoved","set","metadataUpdates","validateOptionalTtl","squashAndAdd","_setUnconditionally","mutate","mutator","add","_setWithIfMatch","obj","remote","assign","setTtl","validateMandatoryTtl","response","_postUpdateToServer","result","_handleSuccessfulUpdateResult","mutatorFunction","error","status","_softSync","request","requestBody","ifMatch","network","post","body","Promise","reject","SyncError","get","then","event","catch","err","locally","_unsubscribe","removeDocument","delete","SyncDocument","syncDocumentImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"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;AACA;;;AACgB,QAANd,MAAM,CAACsB,GAAD,EAAMR,eAAN,EAAuB;AAC/B,SAAK0C,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBtD,MAAtB,CAA6BsB,GAA7B,EAAkCR,eAAlC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANW,MAAM,CAAC/C,GAAD,EAAM;AACd,SAAK8E,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsB7B,MAAtB,CAA6B/C,GAA7B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,QAAdyE,cAAc,GAAG;AACnB,SAAKK,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBH,cAAtB,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIM,EAAAA,KAAK,GAAG;AACJ,UAAMA,KAAN;AACA,SAAKH,gBAAL,CAAsBI,MAAtB,CAA6B,KAAKC,YAAlC;AACH;;AA/J0C;;AAiK/CpG,OAAO,CAAC8F,YAAR,GAAuBA,YAAvB;AACA9F,OAAO,CAAC4C,OAAR,GAAkBkD,YAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncDocumentImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        this.isDeleted = false;\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\n        this.descriptor = descriptor;\n        this.descriptor.data = this.descriptor.data || {};\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'document';\n    }\n    get type() {\n        return 'document';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get data() {\n        return this.descriptor.data;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    /**\n     * Update data entity with new data\n     * @private\n     */\n    _update(update) {\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'document_updated':\n                if (update.id <= this.lastEventId) {\n                    logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\n                    break;\n                }\n                const previousData = this.descriptor.data !== undefined ? sanitize_1.deepClone(this.descriptor.data) : null;\n                this.descriptor.last_event_id = update.id;\n                this.descriptor.revision = update.document_revision;\n                this.descriptor.date_updated = update.date_created;\n                this.descriptor.data = update.document_data;\n                this.broadcastEventToListeners('updated', { data: update.document_data, isLocal: false, previousData });\n                this.services.storage.update(this.type, this.sid, this.uniqueName, {\n                    last_event_id: update.id,\n                    revision: update.document_revision,\n                    date_updated: update.date_created,\n                    data: update.document_data\n                });\n                break;\n            case 'document_removed':\n                this.onRemoved(false);\n                break;\n        }\n    }\n    async set(value, metadataUpdates) {\n        const input = metadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));\n    }\n    async mutate(mutator, metadataUpdates) {\n        const input = metadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));\n    }\n    async update(obj, metadataUpdates) {\n        return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        const response = await this._postUpdateToServer({ ttl });\n        this.descriptor.date_expires = response.date_expires;\n    }\n    /**\n     * @private\n     */\n    async _setUnconditionally(value, ttl) {\n        let result = await this._postUpdateToServer({ data: value, revision: undefined, ttl });\n        this._handleSuccessfulUpdateResult(result);\n        return this.descriptor.data;\n    }\n    /**\n     * @private\n     */\n    async _setWithIfMatch(mutatorFunction, ttl) {\n        let data = mutatorFunction(sanitize_1.deepClone(this.descriptor.data));\n        if (data) {\n            let revision = this.revision;\n            try {\n                let result = await this._postUpdateToServer({ data, revision, ttl });\n                this._handleSuccessfulUpdateResult(result);\n                return this.descriptor.data;\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._softSync();\n                    return this._setWithIfMatch(mutatorFunction);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return this.descriptor.data;\n        }\n    }\n    /**\n     * @private\n     */\n    _handleSuccessfulUpdateResult(result) {\n        // Ignore returned value if we already got a newer one\n        if (result.last_event_id <= this.descriptor.last_event_id) {\n            return;\n        }\n        const previousData = this.descriptor.data !== undefined ? sanitize_1.deepClone(this.descriptor.data) : null;\n        this.descriptor.revision = result.revision;\n        this.descriptor.data = result.data;\n        this.descriptor.last_event_id = result.last_event_id;\n        this.descriptor.date_expires = result.date_expires;\n        this.descriptor.date_updated = new Date(result.date_updated);\n        this.services.storage.update(this.type, this.sid, this.uniqueName, {\n            last_event_id: result.last_event_id,\n            revision: result.revision,\n            date_updated: result.date_updated,\n            data: result.data\n        });\n        this.broadcastEventToListeners('updated', { data: this.descriptor.data, isLocal: true, previousData });\n    }\n    /**\n     * @private\n     */\n    async _postUpdateToServer(request) {\n        if (!this.isDeleted) {\n            const requestBody = {\n                data: request.data\n            };\n            if (request.ttl !== undefined) {\n                requestBody.ttl = request.ttl;\n            }\n            const ifMatch = request.revision;\n            try {\n                const response = await this.services.network.post(this.uri, requestBody, ifMatch);\n                return {\n                    revision: response.body.revision,\n                    data: request.data,\n                    last_event_id: response.body.last_event_id,\n                    date_updated: response.body.date_updated,\n                    date_expires: response.body.date_expires\n                };\n            }\n            catch (error) {\n                if (error.status === 404) {\n                    this.onRemoved(false);\n                }\n                throw error;\n            }\n        }\n        else {\n            return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n        }\n    }\n    /**\n     * Get new data from server\n     * @private\n     */\n    async _softSync() {\n        return this.services.network.get(this.uri)\n            .then(response => {\n            const event = {\n                type: 'document_updated',\n                id: response.body.last_event_id,\n                document_revision: response.body.revision,\n                document_data: response.body.data,\n                date_created: response.body.date_updated\n            };\n            this._update(event);\n            return this;\n        })\n            .catch(err => {\n            if (err.status === 404) {\n                this.onRemoved(false);\n            }\n            else {\n                logger_1.default.error(`Can't get updates for ${this.sid}:`, err);\n            }\n        });\n    }\n    onRemoved(locally) {\n        if (this.isDeleted) {\n            return;\n        }\n        const previousData = this.descriptor.data !== undefined ? sanitize_1.deepClone(this.descriptor.data) : null;\n        this.isDeleted = true;\n        this._unsubscribe();\n        this.removalHandler(this.type, this.sid, this.uniqueName);\n        this.broadcastEventToListeners('removed', { isLocal: locally, previousData });\n    }\n    async removeDocument() {\n        if (!this.isDeleted) {\n            await this.services.network.delete(this.uri);\n            this.onRemoved(true);\n        }\n        else {\n            return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n        }\n    }\n}\nexports.SyncDocumentImpl = SyncDocumentImpl;\n/**\n * @class\n * @alias Document\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\n * Information about rate limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.\n * @property {String} sid The immutable identifier of this document, assigned by the system.\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\n * to this document during creation. Globally unique among other Documents.\n * @property {Date} dateUpdated Date when the Document was last updated.\n * @property {Object} data The contents of this document.\n *\n * @fires Document#removed\n * @fires Document#updated\n */\nclass SyncDocument extends closeable_1.default {\n    constructor(syncDocumentImpl) {\n        super();\n        this.syncDocumentImpl = syncDocumentImpl;\n        this.syncDocumentImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncDocumentImpl.uri;\n    }\n    get revision() {\n        return this.syncDocumentImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncDocumentImpl.lastEventId;\n    }\n    get dateExpires() {\n        return this.syncDocumentImpl.dateExpires;\n    }\n    static get type() {\n        return SyncDocumentImpl.type;\n    }\n    get type() {\n        return SyncDocumentImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncDocumentImpl.sid;\n    }\n    get data() {\n        return this.syncDocumentImpl.data;\n    }\n    get dateUpdated() {\n        return this.syncDocumentImpl.dateUpdated;\n    }\n    get uniqueName() {\n        return this.syncDocumentImpl.uniqueName;\n    }\n    /**\n     * Assign new contents to this document. The current data will be overwritten.\n     * @param {Object} data The new contents to assign.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @returns {Promise<Object>} A promise resolving to the new data of the document.\n     * @public\n     * @example\n     * // Say, the Document data is { name: 'John Smith', age: 34 }\n     * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\n     *   .then(function(newValue) {\n     *     // Now the Document data is { name: 'Barbara Oaks' }\n     *     console.log('Document set() successful, new data:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document set() failed', error);\n     *   });\n     */\n    async set(data, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.set(data, metadataUpdates);\n    }\n    /**\n     * Schedules a modification to this document that will apply a mutation function.\n     * @param {Document~Mutator} mutator A function that outputs a new data based on the existing data.\n     * May be called multiple times, particularly if this Document is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Document will have made the particular transition described\n     * by this function.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\n     *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * document.mutate(mutatorFunction, { ttl: 86400 }))\n     *   .then(function(newValue) {\n     *     console.log('Document mutate() successful, new data:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document mutate() failed', error);\n     *   });\n     */\n    async mutate(mutator, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.mutate(mutator, metadataUpdates);\n    }\n    /**\n     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\n     * This is equivalent to\n     * <pre>\n     * document.mutate(function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @return {Promise<Object>} A promise resolving to the new data of the document.\n     * @public\n     * @example\n     * // Say, the Document data is { name: 'John Smith' }\n     * document.update({ age: 34 }, { ttl: 86400 })\n     *   .then(function(newValue) {\n     *     // Now the Document data is { name: 'John Smith', age: 34 }\n     *     console.log('Document update() successful, new data:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document update() failed', error);\n     *   });\n     */\n    async update(obj, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.update(obj, metadataUpdates);\n    }\n    /**\n     * Update the time-to-live of the document.\n     * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * document.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Document setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.setTtl(ttl);\n    }\n    /**\n     * Delete a document.\n     * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\n     * @public\n     * @example\n     * document.removeDocument()\n     *   .then(function() {\n     *     console.log('Document removeDocument() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document removeDocument() failed', error);\n     *   });\n     */\n    async removeDocument() {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.removeDocument();\n    }\n    /**\n     * Conclude work with the document instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this document will continue operating and receiving events normally.\n     * @public\n     * @example\n     * document.close();\n     */\n    close() {\n        super.close();\n        this.syncDocumentImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncDocument = SyncDocument;\nexports.default = SyncDocument;\n/**\n * Contains Document metadata.\n * @typedef {Object} Document#Metadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the document data.\n * @callback Document~Mutator\n * @param {Object} currentValue The current data of the document in the cloud.\n * @return {Object} The desired new data for the document or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when the document is removed, whether the remover was local or remote.\n * @event Document#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\n * @param {Object} args.previousData Contains a snapshot of the document data before removal.\n * @example\n * document.on('removed', function(args) {\n *   console.log('Document ' + document.sid + ' was removed');\n *   console.log('args.isLocal: ', args.isLocal);\n *   console.log('args.previousData: ', args.previousData);\n * });\n */\n/**\n * Fired when the document's contents have changed, whether the updater was local or remote.\n * @event Document#updated\n * @param {Object} args Arguments provided with the event.\n * @param {Object} args.data A snapshot of the document's new contents.\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\n * @param {Object} args.previousData Contains a snapshot of the document data before the update.\n * @example\n * document.on('updated', function(args) {\n *   console.log('Document ' + document.sid + ' was updated');\n *   console.log('args.data: ', args.data);\n *   console.log('args.isLocal: ', args.isLocal);\n *   console.log('args.previousData: ', args.previousData);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}