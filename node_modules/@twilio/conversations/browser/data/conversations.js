"use strict";

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("../logger");
var conversation_1 = require("../conversation");
exports.Conversation = conversation_1.Conversation;
var deferred_1 = require("../util/deferred");
var util_1 = require("../util");
var log = logger_1.Logger.scope('Conversations');
/**
 * Represents conversations collection
 * {@see Conversation}
 */

var Conversations = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Conversations, _events_1$EventEmitte);

    function Conversations(services) {
        (0, _classCallCheck3.default)(this, Conversations);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Conversations.__proto__ || (0, _getPrototypeOf2.default)(Conversations)).call(this));

        _this.services = services;
        _this.conversations = new _map2.default();
        _this.thumbstones = new _set2.default();
        _this.syncListFetched = false;
        _this.syncListRead = new deferred_1.Deferred();
        return _this;
    }

    (0, _createClass3.default)(Conversations, [{
        key: "getMap",
        value: function getMap() {
            var _this2 = this;

            return this.services.session.getMyConversationsId().then(function (name) {
                return _this2.services.syncClient.map({ id: name, mode: 'open_existing' });
            });
        }
        /**
         * Add conversation to server
         * @private
         * @returns {Promise<Conversation>} Conversation
         */

    }, {
        key: "addConversation",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(options) {
                var attributes, response, conversationSid, conversationDocument, existingConversation, conversation;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                attributes = void 0;

                                if (typeof options.attributes === 'undefined') {
                                    attributes = {};
                                } else {
                                    attributes = options.attributes;
                                }
                                _context.next = 4;
                                return this.services.session.addCommand('createConversation', {
                                    friendlyName: options.friendlyName,
                                    uniqueName: options.uniqueName,
                                    attributes: (0, _stringify2.default)(attributes)
                                });

                            case 4:
                                response = _context.sent;
                                conversationSid = 'conversationSid' in response ? response['conversationSid'] : null;
                                conversationDocument = 'conversation' in response ? response['conversation'] : null;
                                existingConversation = this.conversations.get(conversationSid);

                                if (!existingConversation) {
                                    _context.next = 12;
                                    break;
                                }

                                _context.next = 11;
                                return existingConversation._subscribe();

                            case 11:
                                return _context.abrupt("return", existingConversation);

                            case 12:
                                conversation = new conversation_1.Conversation(this.services, {
                                    channel: conversationDocument,
                                    entityName: null,
                                    uniqueName: null,
                                    attributes: null,
                                    createdBy: null,
                                    friendlyName: null,
                                    lastConsumedMessageIndex: null,
                                    dateCreated: null,
                                    dateUpdated: null
                                }, conversationSid);

                                this.conversations.set(conversation.sid, conversation);
                                this.registerForEvents(conversation);
                                _context.next = 17;
                                return conversation._subscribe();

                            case 17:
                                this.emit('conversationAdded', conversation);
                                return _context.abrupt("return", conversation);

                            case 19:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function addConversation(_x) {
                return _ref.apply(this, arguments);
            }

            return addConversation;
        }()
        /**
         * Fetch conversations list and instantiate all necessary objects
         */

    }, {
        key: "fetchConversations",
        value: function fetchConversations() {
            var _this3 = this;

            this.getMap().then(function () {
                var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(map) {
                    var upserts, paginator, items;
                    return _regenerator2.default.wrap(function _callee2$(_context2) {
                        while (1) {
                            switch (_context2.prev = _context2.next) {
                                case 0:
                                    map.on('itemAdded', function (args) {
                                        log.debug('itemAdded: ' + args.item.key);
                                        _this3.upsertConversation('sync', args.item.key, args.item.data);
                                    });
                                    map.on('itemRemoved', function (args) {
                                        log.debug('itemRemoved: ' + args.key);
                                        var sid = args.key;
                                        if (!_this3.syncListFetched) {
                                            _this3.thumbstones.add(sid);
                                        }
                                        var conversation = _this3.conversations.get(sid);
                                        if (conversation) {
                                            if (conversation && conversation.status === 'joined' /*|| conversation.status === 'invited'*/) {
                                                    conversation._setStatus('notParticipating', 'sync');
                                                    _this3.emit('conversationLeft', conversation);
                                                }
                                            _this3.conversations.delete(sid);
                                            _this3.emit('conversationRemoved', conversation);
                                            conversation.emit('removed', conversation);
                                        }
                                    });
                                    map.on('itemUpdated', function (args) {
                                        log.debug('itemUpdated: ' + args.item.key);
                                        _this3.upsertConversation('sync', args.item.key, args.item.data);
                                    });
                                    upserts = [];
                                    _context2.next = 6;
                                    return _this3.services.syncList.getPage();

                                case 6:
                                    paginator = _context2.sent;
                                    items = paginator.items;

                                    items.forEach(function (item) {
                                        upserts.push(_this3.upsertConversation('synclist', item.channel_sid, item));
                                    });

                                case 9:
                                    if (!paginator.hasNextPage) {
                                        _context2.next = 16;
                                        break;
                                    }

                                    _context2.next = 12;
                                    return paginator.nextPage();

                                case 12:
                                    paginator = _context2.sent;

                                    paginator.items.forEach(function (item) {
                                        upserts.push(_this3.upsertConversation('synclist', item.channel_sid, item));
                                    });
                                    _context2.next = 9;
                                    break;

                                case 16:
                                    _this3.syncListRead.set(true);
                                    return _context2.abrupt("return", _promise2.default.all(upserts));

                                case 18:
                                case "end":
                                    return _context2.stop();
                            }
                        }
                    }, _callee2, _this3);
                }));

                return function (_x2) {
                    return _ref2.apply(this, arguments);
                };
            }()).then(function () {
                _this3.syncListFetched = true;
                _this3.thumbstones.clear();
                log.debug('Conversations list fetched');
            }).then(function () {
                return _this3;
            }).catch(function (e) {
                if (_this3.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get conversations list', e);
                }
                log.debug('ERROR: Failed to get conversations list', e);
                throw e;
            });
        }
    }, {
        key: "_wrapPaginator",
        value: function _wrapPaginator(page, op) {
            var _this4 = this;

            return op(page.items).then(function (items) {
                return {
                    items: items,
                    hasNextPage: page.hasNextPage,
                    hasPrevPage: page.hasPrevPage,
                    nextPage: function nextPage() {
                        return page.nextPage().then(function (x) {
                            return _this4._wrapPaginator(x, op);
                        });
                    },
                    prevPage: function prevPage() {
                        return page.prevPage().then(function (x) {
                            return _this4._wrapPaginator(x, op);
                        });
                    }
                };
            });
        }
    }, {
        key: "getConversations",
        value: function getConversations(args) {
            var _this5 = this;

            return this.getMap().then(function (conversationsMap) {
                return conversationsMap.getItems(args);
            }).then(function (page) {
                return _this5._wrapPaginator(page, function (items) {
                    return _promise2.default.all(items.map(function (item) {
                        return _this5.upsertConversation('sync', item.key, item.data);
                    }));
                });
            });
        }
    }, {
        key: "getConversation",
        value: function getConversation(sid) {
            var _this6 = this;

            return this.getMap().then(function (conversationsMap) {
                return conversationsMap.getItems({ key: sid });
            }).then(function (page) {
                return page.items.map(function (item) {
                    return _this6.upsertConversation('sync', item.key, item.data);
                });
            }).then(function (items) {
                return items.length > 0 ? items[0] : null;
            });
        }
    }, {
        key: "getConversationByUniqueName",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(uniqueName) {
                var _a, _b, links, url, response, body, sid, data;

                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _context3.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context3.sent;
                                url = new util_1.UriBuilder(links.myChannelsUrl).path(uniqueName).build();
                                _context3.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context3.sent;
                                body = response.body;
                                sid = body.channel_sid;
                                data = {
                                    entityName: null,
                                    lastConsumedMessageIndex: body.last_consumed_message_index,
                                    status: ((_a = body) === null || _a === void 0 ? void 0 : _a.status) || 'unknown',
                                    friendlyName: body.friendly_name,
                                    dateUpdated: body.date_updated,
                                    dateCreated: body.date_created,
                                    uniqueName: body.unique_name,
                                    createdBy: body.created_by,
                                    attributes: body.attributes,
                                    channel: sid + ".channel",
                                    notificationLevel: (_b = body) === null || _b === void 0 ? void 0 : _b.notification_level,
                                    sid: sid
                                };
                                return _context3.abrupt("return", this.upsertConversation('sync', sid, data));

                            case 11:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function getConversationByUniqueName(_x3) {
                return _ref3.apply(this, arguments);
            }

            return getConversationByUniqueName;
        }()
    }, {
        key: "getWhisperConversation",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(sid) {
                var _a, _b, _c, _d, links, url, response, body, state, data;

                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                _context4.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context4.sent;
                                url = new util_1.UriBuilder(links.publicChannelsUrl).path(sid).build();
                                _context4.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context4.sent;
                                body = response.body;

                                if (!(body.type !== 'private')) {
                                    _context4.next = 10;
                                    break;
                                }

                                return _context4.abrupt("return");

                            case 10:
                                // todo: refactor this after the back-end change.
                                // Currently, a conversation that is created using a non-conversations-specific
                                // endpoint (i.e., a chat-specific endpoint) will not have a state property set.
                                // The back-end team will fix this, but only when they get some more time to work
                                // on this. For now, the SDK will assume that the default state is active when
                                // the property is absent from the REST response. The back-end team also mentioned
                                // that the state property will become a proper JSON object, as opposed to a JSON
                                // string, which is also covered in the following code.
                                state = void 0;
                                // If the state property is a string, it's expected to be a string that represents
                                // a JSON object.

                                if (typeof body.state === 'string') {
                                    state = JSON.parse(body.state);
                                }
                                // If the state property is already a non-nullable object, then no JSON parsing is
                                // required.
                                if ((0, _typeof3.default)(body.state) === 'object' && body.state !== null) {
                                    state = body.state;
                                }

                                if (!(((_b = (_a = state) === null || _a === void 0 ? void 0 : _a['state.v1']) === null || _b === void 0 ? void 0 : _b.current) === 'closed')) {
                                    _context4.next = 15;
                                    break;
                                }

                                return _context4.abrupt("return");

                            case 15:
                                data = {
                                    entityName: null,
                                    lastConsumedMessageIndex: body.last_consumed_message_index,
                                    status: ((_c = body) === null || _c === void 0 ? void 0 : _c.status) || 'unknown',
                                    friendlyName: body.friendly_name,
                                    dateUpdated: body.date_updated,
                                    dateCreated: body.date_created,
                                    uniqueName: body.unique_name,
                                    createdBy: body.created_by,
                                    attributes: body.attributes,
                                    channel: sid + ".channel",
                                    notificationLevel: (_d = body) === null || _d === void 0 ? void 0 : _d.notification_level,
                                    sid: sid
                                };
                                return _context4.abrupt("return", this.upsertConversation('sync', sid, data));

                            case 17:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function getWhisperConversation(_x4) {
                return _ref4.apply(this, arguments);
            }

            return getWhisperConversation;
        }()
    }, {
        key: "upsertConversation",
        value: function upsertConversation(source, sid, data) {
            var _this7 = this;

            log.trace('upsertConversation(sid=' + sid + ', data=', data);
            var conversation = this.conversations.get(sid);
            // Update the Conversation's status if we know about it
            if (conversation) {
                log.trace('upsertConversation: conversation ' + sid + ' is known and it\'s' + ' status is known from source ' + conversation._statusSource() + ' and update came from source ' + source, conversation);
                if (typeof conversation._statusSource() === 'undefined' || source === conversation._statusSource() || source === 'synclist' && conversation._statusSource() !== 'sync' || source === 'sync') {
                    if (data.status === 'joined' && conversation.status !== 'joined') {
                        conversation._setStatus('joined', source);
                        var updateData = {};
                        if (typeof data.notificationLevel !== 'undefined') {
                            updateData.notificationLevel = data.notificationLevel;
                        }
                        if (typeof data.lastConsumedMessageIndex !== 'undefined') {
                            updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                        }
                        if (!util_1.isDeepEqual(updateData, {})) {
                            conversation._update(updateData);
                        }
                        conversation._subscribe().then(function () {
                            _this7.emit('conversationJoined', conversation);
                        });
                    } else if (data.status === 'notParticipating' && conversation.status === 'joined') {
                        conversation._setStatus('notParticipating', source);
                        conversation._update(data);
                        conversation._subscribe().then(function () {
                            _this7.emit('conversationLeft', conversation);
                        });
                    } else if (data.status === 'notParticipating') {
                        conversation._subscribe();
                    } else {
                        conversation._update(data);
                    }
                } else {
                    log.trace('upsertConversation: conversation is known from sync and came from chat, ignoring', {
                        sid: sid,
                        data: data.status,
                        conversation: conversation.status
                    });
                }
                return conversation._subscribe().then(function () {
                    return conversation;
                });
            }
            if ((source === 'chat' || source === 'synclist') && this.thumbstones.has(sid)) {
                // if conversation was deleted, we ignore it
                log.trace('upsertConversation: conversation is deleted and came again from chat, ignoring', sid);
                return;
            }
            // Fetch the Conversation if we don't know about it
            log.trace('upsertConversation: creating local conversation object with sid ' + sid, data);
            conversation = new conversation_1.Conversation(this.services, data, sid);
            this.conversations.set(sid, conversation);
            return conversation._subscribe().then(function () {
                _this7.registerForEvents(conversation);
                _this7.emit('conversationAdded', conversation);
                if (data.status === 'joined') {
                    conversation._setStatus('joined', source);
                    _this7.emit('conversationJoined', conversation);
                }
                return conversation;
            });
        }
    }, {
        key: "onConversationRemoved",
        value: function onConversationRemoved(sid) {
            var conversation = this.conversations.get(sid);
            if (conversation) {
                this.conversations.delete(sid);
                this.emit('conversationRemoved', conversation);
            }
        }
    }, {
        key: "registerForEvents",
        value: function registerForEvents(conversation) {
            var _this8 = this;

            conversation.on('removed', function () {
                return _this8.onConversationRemoved(conversation.sid);
            });
            conversation.on('updated', function (args) {
                return _this8.emit('conversationUpdated', args);
            });
            conversation.on('participantJoined', this.emit.bind(this, 'participantJoined'));
            conversation.on('participantLeft', this.emit.bind(this, 'participantLeft'));
            conversation.on('participantUpdated', function (args) {
                return _this8.emit('participantUpdated', args);
            });
            conversation.on('messageAdded', this.emit.bind(this, 'messageAdded'));
            conversation.on('messageUpdated', function (args) {
                return _this8.emit('messageUpdated', args);
            });
            conversation.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
            conversation.on('typingStarted', this.emit.bind(this, 'typingStarted'));
            conversation.on('typingEnded', this.emit.bind(this, 'typingEnded'));
        }
    }]);
    return Conversations;
}(events_1.EventEmitter);

exports.Conversations = Conversations;