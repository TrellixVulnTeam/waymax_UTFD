"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _metadata = require("babel-runtime/core-js/reflect/metadata");

var _metadata2 = _interopRequireDefault(_metadata);

var _defineProperty = require("babel-runtime/core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _getOwnPropertyDescriptor = require("babel-runtime/core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = (0, _getOwnPropertyDescriptor2.default)(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof3.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && (0, _defineProperty2.default)(target, key, r), r;
};
var __metadata = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof3.default)(Reflect)) === "object" && typeof _metadata2.default === "function") return (0, _metadata2.default)(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("./logger");
var configuration_1 = require("./configuration");
var user_1 = require("./user");
exports.User = user_1.User;
var network_1 = require("./services/network");
var notificationtypes_1 = require("./interfaces/notificationtypes");
var synclist_1 = require("./synclist");
var twilsock_1 = require("twilsock");
var twilio_notifications_1 = require("twilio-notifications");
var twilio_sync_1 = require("twilio-sync");
var twilio_mcs_client_1 = require("twilio-mcs-client");
var session_1 = require("./session");
var conversations_1 = require("./data/conversations");
var users_1 = require("./data/users");
var typingindicator_1 = require("./services/typingindicator");
var readhorizon_1 = require("./services/readhorizon");
var pushnotification_1 = require("./pushnotification");
exports.PushNotification = pushnotification_1.PushNotification;
var util_1 = require("./util");
var telemetrytracker_1 = require("twilsock/lib/services/telemetrytracker");
var twilio_sdk_type_validator_1 = require("twilio-sdk-type-validator");
var log = logger_1.Logger.scope('Client');
var SDK_VERSION = require('./../package.json').version;

var ClientServices = function ClientServices() {
    (0, _classCallCheck3.default)(this, ClientServices);
};
/**
 * A Client is a starting point to access Twilio Conversations functionality.
 *
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Conversations client
 *
 * @fires Client#connectionError
 * @fires Client#connectionStateChanged
 * @fires Client#conversationAdded
 * @fires Client#conversationJoined
 * @fires Client#conversationLeft
 * @fires Client#conversationRemoved
 * @fires Client#conversationUpdated
 * @fires Client#participantJoined
 * @fires Client#participantLeft
 * @fires Client#participantUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#tokenAboutToExpire
 * @fires Client#tokenExpired
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */


var Client = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Client, _events_1$EventEmitte);

    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * These options can be passed to {@link Client#createConversation}.
     * @typedef {Object} Client#CreateConversationOptions
     * @property {any} [attributes] - Any custom attributes to attach to the Conversation
     * @property {String} [friendlyName] - The non-unique display name of the Conversation
     * @property {String} [uniqueName] - The unique identifier of the Conversation
     */
    /**
     * Connection state of Client.
     * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState
     */
    /**
     * Notifications channel type.
     * @typedef {('fcm'|'apn')} Client#NotificationsChannelType
     */
    function Client(token, options) {
        (0, _classCallCheck3.default)(this, Client);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Client.__proto__ || (0, _getPrototypeOf2.default)(Client)).call(this));

        _this.connectionState = 'connecting';
        _this.sessionPromise = null;
        _this.conversationsPromise = null;
        _this.version = SDK_VERSION;
        _this.parsePushNotification = Client.parsePushNotification;
        _this.options = options || {};
        if (!_this.options.disableDeepClone) {
            var _options = (0, _assign2.default)((0, _assign2.default)({}, _this.options), { transport: undefined, twilsockClient: undefined });
            _options = util_1.deepClone(_options);
            _options.transport = _this.options.transport;
            _options.twilsockClient = _this.options.twilsockClient;
            _this.options = _options;
        }
        _this.options.logLevel = _this.options.logLevel || 'silent';
        log.setLevel(_this.options.logLevel);
        var productId = _this.options.productId = 'ip_messaging';
        // Filling ClientMetadata
        _this.options.clientMetadata = _this.options.clientMetadata || {};
        if (!_this.options.clientMetadata.hasOwnProperty('type')) {
            _this.options.clientMetadata.type = 'conversations';
        }
        if (!_this.options.clientMetadata.hasOwnProperty('sdk')) {
            _this.options.clientMetadata.sdk = 'JS';
            _this.options.clientMetadata.sdkv = SDK_VERSION;
        }
        // Enable session local storage for Sync
        _this.options.Sync = _this.options.Sync || {};
        if (typeof _this.options.Sync.enableSessionStorage === 'undefined') {
            _this.options.Sync.enableSessionStorage = true;
        }
        if (_this.options.region) {
            _this.options.Sync.region = _this.options.region;
        }
        if (!token) {
            throw new Error('A valid Twilio token should be provided');
        }
        _this.services = new ClientServices();
        _this.config = new configuration_1.Configuration(_this.options);
        _this.options.twilsockClient = _this.options.twilsockClient || new twilsock_1.Twilsock(token, productId, _this.options);
        _this.options.transport = _this.options.transport || _this.options.twilsockClient;
        _this.options.notificationsClient = _this.options.notificationsClient || new twilio_notifications_1.Notifications(token, _this.options);
        _this.options.syncClient = _this.options.syncClient || new twilio_sync_1.SyncClient(token, _this.options);
        _this.services.syncClient = _this.options.syncClient;
        _this.services.transport = _this.options.transport;
        _this.services.twilsockClient = _this.options.twilsockClient;
        _this.services.notificationClient = _this.options.notificationsClient;
        _this.services.session = new session_1.Session(_this.services, _this.config);
        _this.sessionPromise = _this.services.session.initialize();
        _this.services.network = new network_1.Network(_this.config, _this.services);
        _this.services.users = new users_1.Users({
            session: _this.services.session,
            network: _this.services.network,
            syncClient: _this.services.syncClient
        });
        _this.services.users.on('userSubscribed', _this.emit.bind(_this, 'userSubscribed'));
        _this.services.users.on('userUpdated', function (args) {
            return _this.emit('userUpdated', args);
        });
        _this.services.users.on('userUnsubscribed', _this.emit.bind(_this, 'userUnsubscribed'));
        _this.services.twilsockClient.on('tokenAboutToExpire', function (ttl) {
            return _this.emit('tokenAboutToExpire', ttl);
        });
        _this.services.twilsockClient.on('tokenExpired', function () {
            return _this.emit('tokenExpired');
        });
        _this.services.twilsockClient.on('connectionError', function (error) {
            return _this.emit('connectionError', error);
        });
        _this.services.readHorizon = new readhorizon_1.ReadHorizon(_this.services);
        _this.services.typingIndicator = new typingindicator_1.TypingIndicator(_this.config, {
            transport: _this.services.twilsockClient,
            notificationClient: _this.services.notificationClient
        }, _this.getConversationBySid.bind(_this));
        _this.services.syncList = new synclist_1.SyncList(_this.services);
        _this.conversations = new conversations_1.Conversations(_this.services);
        _this.conversationsPromise = _this.sessionPromise.then(function () {
            _this.conversations.on('conversationAdded', _this.emit.bind(_this, 'conversationAdded'));
            _this.conversations.on('conversationRemoved', _this.emit.bind(_this, 'conversationRemoved'));
            _this.conversations.on('conversationJoined', _this.emit.bind(_this, 'conversationJoined'));
            _this.conversations.on('conversationLeft', _this.emit.bind(_this, 'conversationLeft'));
            _this.conversations.on('conversationUpdated', function (args) {
                return _this.emit('conversationUpdated', args);
            });
            _this.conversations.on('participantJoined', _this.emit.bind(_this, 'participantJoined'));
            _this.conversations.on('participantLeft', _this.emit.bind(_this, 'participantLeft'));
            _this.conversations.on('participantUpdated', function (args) {
                return _this.emit('participantUpdated', args);
            });
            _this.conversations.on('messageAdded', _this.emit.bind(_this, 'messageAdded'));
            _this.conversations.on('messageUpdated', function (args) {
                return _this.emit('messageUpdated', args);
            });
            _this.conversations.on('messageRemoved', _this.emit.bind(_this, 'messageRemoved'));
            _this.conversations.on('typingStarted', _this.emit.bind(_this, 'typingStarted'));
            _this.conversations.on('typingEnded', _this.emit.bind(_this, 'typingEnded'));
            return _this.conversations.fetchConversations();
        }).then(function () {
            return _this.conversations;
        });
        _this.services.notificationClient.on('connectionStateChanged', function (state) {
            var changedConnectionState = null;
            switch (state) {
                case 'connected':
                    changedConnectionState = 'connected';
                    break;
                case 'denied':
                    changedConnectionState = 'denied';
                    break;
                case 'disconnecting':
                    changedConnectionState = 'disconnecting';
                    break;
                case 'disconnected':
                    changedConnectionState = 'disconnected';
                    break;
                default:
                    changedConnectionState = 'connecting';
            }
            if (changedConnectionState !== _this.connectionState) {
                _this.connectionState = changedConnectionState;
                _this.emit('connectionStateChanged', _this.connectionState);
            }
        });
        _this.fpaToken = token;
        return _this;
    }
    /**
     * Factory method to create Conversations client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} [options] - Options to customize the Client
     * @returns {Promise<Client>}
     */


    (0, _createClass3.default)(Client, [{
        key: "subscribeToPushNotifications",
        value: function subscribeToPushNotifications(channelType) {
            var _this2 = this;

            var subscriptions = [];
            [notificationtypes_1.NotificationTypes.NEW_MESSAGE, notificationtypes_1.NotificationTypes.ADDED_TO_CONVERSATION, notificationtypes_1.NotificationTypes.REMOVED_FROM_CONVERSATION, notificationtypes_1.NotificationTypes.TYPING_INDICATOR, notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {
                subscriptions.push(_this2.services.notificationClient.subscribe(messageType, channelType));
            });
            return _promise2.default.all(subscriptions);
        }
    }, {
        key: "unsubscribeFromPushNotifications",
        value: function unsubscribeFromPushNotifications(channelType) {
            var _this3 = this;

            var subscriptions = [];
            [notificationtypes_1.NotificationTypes.NEW_MESSAGE, notificationtypes_1.NotificationTypes.ADDED_TO_CONVERSATION, notificationtypes_1.NotificationTypes.REMOVED_FROM_CONVERSATION, notificationtypes_1.NotificationTypes.TYPING_INDICATOR, notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {
                subscriptions.push(_this3.services.notificationClient.unsubscribe(messageType, channelType));
            });
            return _promise2.default.all(subscriptions);
        }
    }, {
        key: "initialize",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var _this4 = this;

                var links, options;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.sessionPromise;

                            case 2:
                                Client.supportedPushChannels.forEach(function (channelType) {
                                    return _this4.subscribeToPushNotifications(channelType);
                                });
                                _context.next = 5;
                                return this.services.session.getSessionLinks();

                            case 5:
                                links = _context.sent;
                                options = (0, _assign2.default)(this.options);

                                options.transport = null;
                                this.services.mcsClient = new twilio_mcs_client_1.McsClient(this.fpaToken, links.mediaServiceUrl, options);
                                _context.next = 11;
                                return this.services.typingIndicator.initialize();

                            case 11:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function initialize() {
                return _ref.apply(this, arguments);
            }

            return initialize;
        }()
        /**
         * Gracefully shutting down library instance.
         * @public
         * @returns {Promise<void>}
         */

    }, {
        key: "shutdown",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _context2.next = 2;
                                return this.services.twilsockClient.disconnect();

                            case 2:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function shutdown() {
                return _ref2.apply(this, arguments);
            }

            return shutdown;
        }()
        /**
         * Update the token used by the Client and re-register with Conversations services.
         * @param {String} token - Access token
         * @public
         * @returns {Promise<Client>}
         */

    }, {
        key: "updateToken",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(token) {
                var _this5 = this;

                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                log.info('updateToken');

                                if (!(this.fpaToken === token)) {
                                    _context3.next = 3;
                                    break;
                                }

                                return _context3.abrupt("return", this);

                            case 3:
                                _context3.next = 5;
                                return this.services.twilsockClient.updateToken(token).then(function () {
                                    return _this5.fpaToken = token;
                                }).then(function () {
                                    return _this5.services.mcsClient.updateToken(token);
                                }).then(function () {
                                    return _this5.sessionPromise;
                                });

                            case 5:
                                return _context3.abrupt("return", this);

                            case 6:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function updateToken(_x) {
                return _ref3.apply(this, arguments);
            }

            return updateToken;
        }()
        /**
         * Get a known Conversation by its SID.
         * @param {String} conversationSid - Conversation sid
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "getConversationBySid",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(conversationSid) {
                var conversation;
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                _context4.next = 2;
                                return this.conversations.syncListRead.promise;

                            case 2:
                                _context4.next = 4;
                                return this.conversations.getConversation(conversationSid);

                            case 4:
                                conversation = _context4.sent;

                                if (conversation) {
                                    _context4.next = 9;
                                    break;
                                }

                                _context4.next = 8;
                                return this.conversations.getWhisperConversation(conversationSid);

                            case 8:
                                conversation = _context4.sent;

                            case 9:
                                if (conversation) {
                                    _context4.next = 11;
                                    break;
                                }

                                throw new Error("Conversation with SID " + conversationSid + " is not found.");

                            case 11:
                                return _context4.abrupt("return", conversation);

                            case 12:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function getConversationBySid(_x2) {
                return _ref4.apply(this, arguments);
            }

            return getConversationBySid;
        }()
        /**
         * Get a known Conversation by its unique identifier name.
         * @param {String} uniqueName - The unique identifier name of the Conversation to get
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "getConversationByUniqueName",
        value: function () {
            var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(uniqueName) {
                var conversation;
                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                _context5.next = 2;
                                return this.conversations.syncListRead.promise;

                            case 2:
                                _context5.next = 4;
                                return this.conversations.getConversationByUniqueName(uniqueName);

                            case 4:
                                conversation = _context5.sent;

                                if (conversation) {
                                    _context5.next = 7;
                                    break;
                                }

                                throw new Error("Conversation with unique name " + uniqueName + " is not found.");

                            case 7:
                                return _context5.abrupt("return", conversation);

                            case 8:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this);
            }));

            function getConversationByUniqueName(_x3) {
                return _ref5.apply(this, arguments);
            }

            return getConversationByUniqueName;
        }()
        /**
         * Get the current list of all subscribed Conversations.
         * @returns {Promise<Paginator<Conversation>>}
         */

    }, {
        key: "getSubscribedConversations",
        value: function getSubscribedConversations(args) {
            return this.conversationsPromise.then(function (conversations) {
                return conversations.getConversations(args);
            });
        }
        /**
         * Create a Conversation on the server and subscribe to its events.
         * The default is a Conversation with an empty friendlyName.
         * @param {Client#CreateConversationOptions} [options] - Options for the Conversation
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "createConversation",
        value: function createConversation(options) {
            options = options || {};
            return this.conversationsPromise.then(function (conversationsEntity) {
                return conversationsEntity.addConversation(options);
            });
        }
        /**
         * Registers for push notifications.
         * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported
         * @param {string} registrationId - Push notification id provided by the platform
         * @returns {Promise<void>}
         */

    }, {
        key: "setPushRegistrationId",
        value: function () {
            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(channelType, registrationId) {
                var _this6 = this;

                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                _context6.next = 2;
                                return this.subscribeToPushNotifications(channelType).then(function () {
                                    return _this6.services.notificationClient.setPushRegistrationId(registrationId, channelType);
                                });

                            case 2:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));

            function setPushRegistrationId(_x4, _x5) {
                return _ref6.apply(this, arguments);
            }

            return setPushRegistrationId;
        }()
        /**
         * Unregisters from push notifications.
         * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported
         * @returns {Promise<void>}
         */

    }, {
        key: "unsetPushRegistrationId",
        value: function () {
            var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(channelType) {
                return _regenerator2.default.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                if (!(Client.supportedPushChannels.indexOf(channelType) === -1)) {
                                    _context7.next = 2;
                                    break;
                                }

                                throw new Error('Invalid or unsupported channelType: ' + channelType);

                            case 2:
                                _context7.next = 4;
                                return this.unsubscribeFromPushNotifications(channelType);

                            case 4:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));

            function unsetPushRegistrationId(_x6) {
                return _ref7.apply(this, arguments);
            }

            return unsetPushRegistrationId;
        }()
    }, {
        key: "handlePushNotification",

        /**
         * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
         * @param {Object} notificationPayload - Push notification payload
         * @returns {Promise<void>}
         */
        value: function () {
            var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(notificationPayload) {
                return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                        switch (_context8.prev = _context8.next) {
                            case 0:
                                log.debug('handlePushNotification, notificationPayload=', notificationPayload);
                                this.emit('pushNotification', Client.parsePushNotification(notificationPayload));

                            case 2:
                            case "end":
                                return _context8.stop();
                        }
                    }
                }, _callee8, this);
            }));

            function handlePushNotification(_x7) {
                return _ref8.apply(this, arguments);
            }

            return handlePushNotification;
        }()
        /**
         * Gets user for given identity, if it's in subscribed list - then return the user object from it,
         * if not - then subscribes and adds user to the subscribed list.
         * @param {String} identity - Identity of User
         * @returns {Promise<User>} Fully initialized user
         */

    }, {
        key: "getUser",
        value: function getUser(identity) {
            return this.services.users.getUser(identity);
        }
        /**
         * @returns {Promise<Array<User>>} List of subscribed User objects
         */

    }, {
        key: "getSubscribedUsers",
        value: function () {
            var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
                return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                        switch (_context9.prev = _context9.next) {
                            case 0:
                                return _context9.abrupt("return", this.services.users.getSubscribedUsers());

                            case 1:
                            case "end":
                                return _context9.stop();
                        }
                    }
                }, _callee9, this);
            }));

            function getSubscribedUsers() {
                return _ref9.apply(this, arguments);
            }

            return getSubscribedUsers;
        }()
    }, {
        key: "user",
        get: function get() {
            return this.services.users.myself;
        }
    }, {
        key: "reachabilityEnabled",
        get: function get() {
            return this.services.session.reachabilityEnabled;
        }
    }, {
        key: "token",
        get: function get() {
            return this.fpaToken;
        }
    }], [{
        key: "create",
        value: function () {
            var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(token, options) {
                var client, startupEvent;
                return _regenerator2.default.wrap(function _callee10$(_context10) {
                    while (1) {
                        switch (_context10.prev = _context10.next) {
                            case 0:
                                client = new Client(token, options);
                                startupEvent = 'conversations.client.startup';

                                client.services.twilsockClient.addPartialTelemetryEvent(new telemetrytracker_1.TelemetryEventDescription(startupEvent, 'Conversations client startup', new Date()), startupEvent, telemetrytracker_1.TelemetryPoint.Start);
                                _context10.next = 5;
                                return client.initialize();

                            case 5:
                                client.services.twilsockClient.addPartialTelemetryEvent(new telemetrytracker_1.TelemetryEventDescription('', '', new Date()), startupEvent, telemetrytracker_1.TelemetryPoint.End);
                                return _context10.abrupt("return", client);

                            case 7:
                            case "end":
                                return _context10.stop();
                        }
                    }
                }, _callee10, this);
            }));

            function create(_x8, _x9) {
                return _ref10.apply(this, arguments);
            }

            return create;
        }()
    }, {
        key: "parsePushNotificationChatData",
        value: function parsePushNotificationChatData(data) {
            var result = {};
            for (var key in Client.supportedPushDataFields) {
                if (typeof data[key] !== 'undefined' && data[key] !== null) {
                    if (key === 'message_index') {
                        if (util_1.parseToNumber(data[key]) !== null) {
                            result[Client.supportedPushDataFields[key]] = Number(data[key]);
                        }
                    } else {
                        result[Client.supportedPushDataFields[key]] = data[key];
                    }
                }
            }
            return result;
        }
        /**
         * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
         * @param {Object} notificationPayload - Push notification payload
         * @returns {PushNotification|Error}
         */

    }, {
        key: "parsePushNotification",
        value: function parsePushNotification(notificationPayload) {
            log.debug('parsePushNotification, notificationPayload=', notificationPayload);
            // APNS specifics
            if (typeof notificationPayload.aps !== 'undefined') {
                if (!notificationPayload.twi_message_type) {
                    throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
                }
                var data = Client.parsePushNotificationChatData(notificationPayload);
                var apsPayload = notificationPayload.aps;
                var body = null;
                var title = null;
                if (typeof apsPayload.alert === 'string') {
                    body = apsPayload.alert || null;
                } else {
                    body = apsPayload.alert.body || null;
                    title = apsPayload.alert.title || null;
                }
                return new pushnotification_1.PushNotification({
                    title: title,
                    body: body,
                    sound: apsPayload.sound || null,
                    badge: apsPayload.badge || null,
                    action: apsPayload.category || null,
                    type: notificationPayload.twi_message_type,
                    data: data
                });
            }
            // FCM specifics
            if (typeof notificationPayload.data !== 'undefined') {
                var dataPayload = notificationPayload.data;
                if (!dataPayload.twi_message_type) {
                    throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
                }
                var _data = Client.parsePushNotificationChatData(notificationPayload.data);
                return new pushnotification_1.PushNotification({
                    title: dataPayload.twi_title || null,
                    body: dataPayload.twi_body || null,
                    sound: dataPayload.twi_sound || null,
                    badge: null,
                    action: dataPayload.twi_action || null,
                    type: dataPayload.twi_message_type,
                    data: _data
                });
            }
            throw new Error('Provided push notification payload is not Programmable Chat notification');
        }
    }]);
    return Client;
}(events_1.EventEmitter);

Client.version = SDK_VERSION;
Client.supportedPushChannels = ['fcm', 'apn'];
Client.supportedPushDataFields = {
    'conversation_sid': 'conversationSid',
    'message_sid': 'messageSid',
    'message_index': 'messageIndex'
};
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Client.prototype, "updateToken", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Client.prototype, "getConversationBySid", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Client.prototype, "getConversationByUniqueName", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(['undefined', twilio_sdk_type_validator_1.objectSchema('conversation options', {
    friendlyName: ['string', 'undefined'],
    isPrivate: ['boolean', 'undefined'],
    uniqueName: ['string', 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", _promise2.default)], Client.prototype, "createConversation", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.literal('fcm', 'apn'), 'string'), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", _promise2.default)], Client.prototype, "setPushRegistrationId", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.literal('fcm', 'apn')), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Client.prototype, "unsetPushRegistrationId", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", _promise2.default)], Client.prototype, "handlePushNotification", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Client.prototype, "getUser", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync('string', ['undefined', twilio_sdk_type_validator_1.pureObject]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", _promise2.default)], Client, "create", null);
__decorate([twilio_sdk_type_validator_1.validateTypes(twilio_sdk_type_validator_1.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", pushnotification_1.PushNotification)], Client, "parsePushNotification", null);
exports.Client = Client;
exports.default = Client;
/**
 * Fired when a Conversation becomes visible to the Client. The event is also triggered when the client creates a new Conversation.
 * Fired for all conversations Client has joined.
 * @event Client#conversationAdded
 * @type {Conversation}
 */
/**
 * Fired when the Client joins a Conversation.
 * @event Client#conversationJoined
 * @type {Conversation}
 */
/**
 * Fired when the Client leaves a Conversation.
 * @event Client#conversationLeft
 * @type {Conversation}
 */
/**
 * Fired when a Conversation is no longer visible to the Client.
 * @event Client#conversationRemoved
 * @type {Conversation}
 */
/**
 * Fired when a Conversation's attributes or metadata have been updated.
 * During Conversation's {@link Client.create| creation and initialization} this event might be fired multiple times
 * for same joined or created Conversation as new data is arriving from different sources.
 * @event Client#conversationUpdated
 * @type {Object}
 * @property {Conversation} conversation - Updated Conversation
 * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons
 */
/**
 * Fired when Client's connection state has been changed.
 * @event Client#connectionStateChanged
 * @type {Client#ConnectionState}
 */
/**
 * Fired when a Participant has joined the Conversation.
 * @event Client#participantJoined
 * @type {Participant}
 */
/**
 * Fired when a Participant has left the Conversation.
 * @event Client#participantLeft
 * @type {Participant}
 */
/**
 * Fired when a Participant's fields has been updated.
 * @event Client#participantUpdated
 * @type {Object}
 * @property {Participant} participant - Updated Participant
 * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Conversation on the server.
 * @event Client#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Conversation's message list.
 * @event Client#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Client#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when token is about to expire and needs to be updated.
 * @event Client#tokenAboutToExpire
 * @type {void}
 */
/**
 * Fired when token is expired.
 * @event Client#tokenExpired
 * @type {void}
 */
/**
 * Fired when a Participant has stopped typing.
 * @event Client#typingEnded
 * @type {Participant}
 */
/**
 * Fired when a Participant has started typing.
 * @event Client#typingStarted
 * @type {Participant}
 */
/**
 * Fired when client received (and parsed) push notification via one of push channels (apn or fcm).
 * @event Client#pushNotification
 * @type {PushNotification}
 */
/**
 * Fired when the Client is subscribed to a User.
 * @event Client#userSubscribed
 * @type {User}
 */
/**
 * Fired when the Client is unsubscribed from a User.
 * @event Client#userUnsubscribed
 * @type {User}
 */
/**
 * Fired when the User's properties or reachability status have been updated.
 * @event Client#userUpdated
 * @type {Object}
 * @property {User} user - Updated User
 * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons
 */
/**
 * Fired when connection is interrupted by unexpected reason
 * @event Client#connectionError
 * @type {Object}
 * @property {Boolean} terminal - twilsock will stop connection attempts
 * @property {String} message - root cause
 * @property {Number} [httpStatusCode] - http status code if available
 * @property {Number} [errorCode] - Twilio public error code if available
 */