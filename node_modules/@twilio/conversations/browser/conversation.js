"use strict";

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _isInteger = require("babel-runtime/core-js/number/is-integer");

var _isInteger2 = _interopRequireDefault(_isInteger);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _metadata = require("babel-runtime/core-js/reflect/metadata");

var _metadata2 = _interopRequireDefault(_metadata);

var _defineProperty = require("babel-runtime/core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _getOwnPropertyDescriptor = require("babel-runtime/core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = (0, _getOwnPropertyDescriptor2.default)(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof3.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && (0, _defineProperty2.default)(target, key, r), r;
};
var __metadata = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof3.default)(Reflect)) === "object" && typeof _metadata2.default === "function") return (0, _metadata2.default)(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("./logger");
var participants_1 = require("./data/participants");
var participant_1 = require("./participant");
var messages_1 = require("./data/messages");
var util_1 = require("./util");
var twilio_sdk_type_validator_1 = require("twilio-sdk-type-validator");
var log = logger_1.Logger.scope('Conversation');
var fieldMappings = {
    lastMessage: 'lastMessage',
    attributes: 'attributes',
    createdBy: 'createdBy',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    friendlyName: 'friendlyName',
    lastConsumedMessageIndex: 'lastConsumedMessageIndex',
    notificationLevel: 'notificationLevel',
    sid: 'sid',
    status: 'status',
    uniqueName: 'uniqueName',
    state: 'state'
};
function parseTime(timeString) {
    try {
        return new Date(timeString);
    } catch (e) {
        return null;
    }
}
/**
 * @classdesc A Conversation represents communication between multiple Conversations Clients
 * @property {any} attributes - The Conversation's custom attributes
 * @property {String} createdBy - The identity of the User that created this Conversation
 * @property {Date} dateCreated - The Date this Conversation was created
 * @property {Date} dateUpdated - The Date this Conversation was last updated
 * @property {String} [friendlyName] - The Conversation's name
 * @property {Number|null} lastReadMessageIndex - Index of the last Message the User has read in this Conversation
 * @property {Conversation#LastMessage} lastMessage - Last Message sent to this Conversation
 * @property {Conversation#NotificationLevel} notificationLevel - User Notification level for this Conversation
 * @property {String} sid - The Conversation's unique system identifier
 * @property {Conversation#Status} status - The Conversation's status
 * @property {Conversation#State} state - The Conversation's state
 * @property {String} uniqueName - The Conversation's unique name
 * @fires Conversation#participantJoined
 * @fires Conversation#participantLeft
 * @fires Conversation#participantUpdated
 * @fires Conversation#messageAdded
 * @fires Conversation#messageRemoved
 * @fires Conversation#messageUpdated
 * @fires Conversation#typingEnded
 * @fires Conversation#typingStarted
 * @fires Conversation#updated
 * @fires Conversation#removed
 */

var Conversation = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Conversation, _events_1$EventEmitte);

    /**
     * These options can be passed to {@link Conversation#sendMessage}.
     * @typedef {Object} Conversation#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * These options can be passed to {@link Conversation#sendMessage}.
     * @typedef {Object} Conversation#SendEmailOptions
     * @property {String} subject - subject for the message. Ignored for media messages.
     */
    /**
     * The update reason for <code>updated</code> event emitted on Conversation
     * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |
      'friendlyName' | 'lastReadMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |
      'notificationLevel' )} Conversation#UpdateReason
     */
    /**
     * The status of the Conversation, relative to the Client: whether the Conversation has been <code>joined</code> or the Client is
     * <code>notParticipating</code> in the Conversation.
     * @typedef {('notParticipating' | 'joined')} Conversation#Status
     */
    /**
     * The User's Notification level for Conversation, determines whether the currently logged-in User will receive
     * pushes for events in this Conversation. Can be either <code>muted</code> or <code>default</code>,
     * where <code>default</code> defers to global Service push configuration.
     * @typedef {('default' | 'muted')} Conversation#NotificationLevel
     */
    /**
     * The Conversation's state.
     * @typedef {Object} Conversation#State
     * @property {('active' | 'inactive' | 'closed')} current - the current state
     * @property {Date} dateUpdated - date at which the latest conversation state update happened
     */
    function Conversation(services, descriptor, sid) {
        (0, _classCallCheck3.default)(this, Conversation);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Conversation.__proto__ || (0, _getPrototypeOf2.default)(Conversation)).call(this));

        var attributes = descriptor.attributes || {};
        var createdBy = descriptor.createdBy;
        var dateCreated = parseTime(descriptor.dateCreated);
        var dateUpdated = parseTime(descriptor.dateUpdated);
        var friendlyName = descriptor.friendlyName || null;
        var lastReadMessageIndex = (0, _isInteger2.default)(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;
        var uniqueName = descriptor.uniqueName || null;
        try {
            (0, _stringify2.default)(attributes);
        } catch (e) {
            throw new Error('Attributes must be a valid JSON object.');
        }
        _this.services = services;
        _this.sid = sid;
        _this.entityName = descriptor.channel;
        _this.channelState = {
            uniqueName: uniqueName,
            status: 'notParticipating',
            attributes: attributes,
            createdBy: createdBy,
            dateCreated: dateCreated,
            dateUpdated: dateUpdated,
            friendlyName: friendlyName,
            lastReadMessageIndex: lastReadMessageIndex
        };
        if (descriptor.notificationLevel) {
            _this.channelState.notificationLevel = descriptor.notificationLevel;
        }
        _this.participants = new _map2.default();
        _this.participantsEntity = new participants_1.Participants(_this, _this.services, _this.participants);
        _this.participantsEntity.on('participantJoined', _this.emit.bind(_this, 'participantJoined'));
        _this.participantsEntity.on('participantLeft', _this.emit.bind(_this, 'participantLeft'));
        _this.participantsEntity.on('participantUpdated', function (args) {
            return _this.emit('participantUpdated', args);
        });
        _this.messagesEntity = new messages_1.Messages(_this, services);
        _this.messagesEntity.on('messageAdded', function (message) {
            return _this._onMessageAdded(message);
        });
        _this.messagesEntity.on('messageUpdated', function (args) {
            return _this.emit('messageUpdated', args);
        });
        _this.messagesEntity.on('messageRemoved', _this.emit.bind(_this, 'messageRemoved'));
        return _this;
    }

    (0, _createClass3.default)(Conversation, [{
        key: "_subscribe",

        /**
         * The Conversation's last message's information.
         * @typedef {Object} Conversation#LastMessage
         * @property {Number} index - Message's index
         * @property {Date} dateCreated - Message's creation date
         */
        /**
         * Load and Subscribe to this Conversation and do not subscribe to its Participants and Messages.
         * This or _subscribeStreams will need to be called before any events on Conversation will fire.
         * @returns {Promise}
         * @private
         */
        value: function _subscribe() {
            var _this2 = this;

            if (this.entityPromise) {
                return this.entityPromise;
            }
            return this.entityPromise = this.entityPromise || this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' }).then(function (entity) {
                _this2.entity = entity;
                _this2.entity.on('updated', function (args) {
                    _this2._update(args.data);
                });
                _this2.entity.on('removed', function () {
                    return _this2.emit('removed', _this2);
                });
                _this2._update(_this2.entity.data);
                return entity;
            }).catch(function (err) {
                _this2.entity = null;
                _this2.entityPromise = null;
                if (_this2.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get conversation object', err);
                }
                log.debug('ERROR: Failed to get conversation object', err);
                throw err;
            });
        }
        /**
         * Load the attributes of this Conversation and instantiate its Participants and Messages.
         * This or _subscribe will need to be called before any events on Conversation will fire.
         * This will need to be called before any events on Participants or Messages will fire
         * @returns {Promise}
         * @private
         */

    }, {
        key: "_subscribeStreams",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var messagesObjectName, rosterObjectName;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.prev = 0;
                                _context.next = 3;
                                return this._subscribe();

                            case 3:
                                log.trace('_subscribeStreams, this.entity.data=', this.entity.data);
                                messagesObjectName = this.entity.data.messages;
                                rosterObjectName = this.entity.data.roster;
                                _context.next = 8;
                                return _promise2.default.all([this.messagesEntity.subscribe(messagesObjectName), this.participantsEntity.subscribe(rosterObjectName)]);

                            case 8:
                                _context.next = 15;
                                break;

                            case 10:
                                _context.prev = 10;
                                _context.t0 = _context["catch"](0);

                                if (this.services.syncClient.connectionState !== 'disconnected') {
                                    log.error('Failed to subscribe on conversation objects', this.sid, _context.t0);
                                }
                                log.debug('ERROR: Failed to subscribe on conversation objects', this.sid, _context.t0);
                                throw _context.t0;

                            case 15:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[0, 10]]);
            }));

            function _subscribeStreams() {
                return _ref.apply(this, arguments);
            }

            return _subscribeStreams;
        }()
        /**
         * Stop listening for and firing events on this Conversation.
         * @returns {Promise}
         * @private
         */

    }, {
        key: "_unsubscribe",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!this.entity) {
                                    _context2.next = 5;
                                    break;
                                }

                                _context2.next = 3;
                                return this.entity.close();

                            case 3:
                                this.entity = null;
                                this.entityPromise = null;

                            case 5:
                                return _context2.abrupt("return", _promise2.default.all([this.participantsEntity.unsubscribe(), this.messagesEntity.unsubscribe()]));

                            case 6:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function _unsubscribe() {
                return _ref2.apply(this, arguments);
            }

            return _unsubscribe;
        }()
        /**
         * Set conversation status
         * @private
         */

    }, {
        key: "_setStatus",
        value: function _setStatus(status, source) {
            var _this3 = this;

            this.statusSource = source;
            if (this.channelState.status === status) {
                return;
            }
            this.channelState.status = status;
            if (status === 'joined') {
                this._subscribeStreams().catch(function (err) {
                    log.debug('ERROR while setting conversation status ' + status, err);
                    if (_this3.services.syncClient.connectionState !== 'disconnected') {
                        throw err;
                    }
                });
            } else if (this.entityPromise) {
                this._unsubscribe().catch(function (err) {
                    log.debug('ERROR while setting conversation status ' + status, err);
                    if (_this3.services.syncClient.connectionState !== 'disconnected') {
                        throw err;
                    }
                });
            }
        }
        /**
         * If conversation's status update source
         * @private
         * @return {Conversations.DataSource}
         */

    }, {
        key: "_statusSource",
        value: function _statusSource() {
            return this.statusSource;
        }
    }, {
        key: "_update",

        /**
         * Updates local conversation object with new values
         * @private
         */
        value: function _update(update) {
            var _a, _b, _c, _d, _e;
            log.trace('_update', update);
            Conversation.preprocessUpdate(update, this.sid);
            var updateReasons = new _set2.default();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(update)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var key = _step.value;

                    var localKey = fieldMappings[key];
                    if (!localKey) {
                        continue;
                    }
                    switch (localKey) {
                        case fieldMappings.status:
                            if (!update.status || update.status === 'unknown' || this.channelState.status === update.status) {
                                break;
                            }
                            this.channelState.status = update.status;
                            updateReasons.add(localKey);
                            break;
                        case fieldMappings.attributes:
                            if (util_1.isDeepEqual(this.channelState.attributes, update.attributes)) {
                                break;
                            }
                            this.channelState.attributes = update.attributes;
                            updateReasons.add(localKey);
                            break;
                        case fieldMappings.lastConsumedMessageIndex:
                            if (update.lastConsumedMessageIndex === undefined || update.lastConsumedMessageIndex === this.channelState.lastReadMessageIndex) {
                                break;
                            }
                            this.channelState.lastReadMessageIndex = update.lastConsumedMessageIndex;
                            updateReasons.add('lastReadMessageIndex');
                            break;
                        case fieldMappings.lastMessage:
                            if (this.channelState.lastMessage && !update.lastMessage) {
                                delete this.channelState.lastMessage;
                                updateReasons.add(localKey);
                                break;
                            }
                            this.channelState.lastMessage = this.channelState.lastMessage || {};
                            if (((_a = update.lastMessage) === null || _a === void 0 ? void 0 : _a.index) !== undefined && update.lastMessage.index !== this.channelState.lastMessage.index) {
                                this.channelState.lastMessage.index = update.lastMessage.index;
                                updateReasons.add(localKey);
                            }
                            if (((_b = update.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp) !== undefined && ((_d = (_c = this.channelState.lastMessage) === null || _c === void 0 ? void 0 : _c.dateCreated) === null || _d === void 0 ? void 0 : _d.getTime()) !== update.lastMessage.timestamp.getTime()) {
                                this.channelState.lastMessage.dateCreated = update.lastMessage.timestamp;
                                updateReasons.add(localKey);
                            }
                            if (util_1.isDeepEqual(this.channelState.lastMessage, {})) {
                                delete this.channelState.lastMessage;
                            }
                            break;
                        case fieldMappings.state:
                            var state = update.state || undefined;
                            if (state !== undefined) {
                                state.dateUpdated = new Date(state.dateUpdated);
                            }
                            if (util_1.isDeepEqual(this.channelState.state, state)) {
                                break;
                            }
                            this.channelState.state = state;
                            updateReasons.add(localKey);
                            break;
                        default:
                            var isDate = update[key] instanceof Date;
                            var keysMatchAsDates = isDate && ((_e = this.channelState[localKey]) === null || _e === void 0 ? void 0 : _e.getTime()) === update[key].getTime();
                            var keysMatchAsNonDates = !isDate && this[localKey] === update[key];
                            if (keysMatchAsDates || keysMatchAsNonDates) {
                                break;
                            }
                            this.channelState[localKey] = update[key];
                            updateReasons.add(localKey);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (updateReasons.size > 0) {
                this.emit('updated', { conversation: this, updateReasons: [].concat((0, _toConsumableArray3.default)(updateReasons)) });
            }
        }
        /**
         * @private
         */

    }, {
        key: "_onMessageAdded",
        value: function _onMessageAdded(message) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = (0, _getIterator3.default)(this.participants.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var participant = _step2.value;

                    if (participant.identity === message.author) {
                        participant._endTyping();
                        break;
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            this.emit('messageAdded', message);
        }
        /**
         * Add a participant to the Conversation by its Identity.
         * @param {String} identity - Identity of the Client to add
         * @param {any} [attributes] Attributes to be attached to the participant
         * @returns {Promise<void>}
         */

    }, {
        key: "add",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(identity, attributes) {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                return _context3.abrupt("return", this.participantsEntity.add(identity, attributes));

                            case 1:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function add(_x, _x2) {
                return _ref3.apply(this, arguments);
            }

            return add;
        }()
        /**
         * Add a non-chat participant to the Conversation.
         *
         * @param {String} proxyAddress Proxy (Twilio) address of the participant
         * @param {String} address User address of the participant
         * @param {any} [attributes] Attributes to be attached to the participant
         * @returns {Promise<void>}
         */

    }, {
        key: "addNonChatParticipant",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(proxyAddress, address) {
                var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                return _context4.abrupt("return", this.participantsEntity.addNonChatParticipant(proxyAddress, address, attributes));

                            case 1:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function addNonChatParticipant(_x4, _x5) {
                return _ref4.apply(this, arguments);
            }

            return addNonChatParticipant;
        }()
        /**
         * Advance Conversation's last read Message index to current read horizon.
         * Rejects if User is not Participant of Conversation.
         * Last read Message index is updated only if new index value is higher than previous.
         * @param {Number} index - Message index to advance to as last read
         * @returns {Promise<number>} resulting unread messages count in the conversation
         */

    }, {
        key: "advanceLastReadMessageIndex",
        value: function () {
            var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(index) {
                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                _context5.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context5.abrupt("return", this.services.readHorizon.advanceLastReadMessageIndexForConversation(this.sid, index, this.lastReadMessageIndex));

                            case 3:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this);
            }));

            function advanceLastReadMessageIndex(_x6) {
                return _ref5.apply(this, arguments);
            }

            return advanceLastReadMessageIndex;
        }()
        /**
         * Delete the Conversation and unsubscribe from its events.
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "delete",
        value: function () {
            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                _context6.next = 2;
                                return this.services.session.addCommand('destroyChannel', {
                                    channelSid: this.sid
                                });

                            case 2:
                                return _context6.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));

            function _delete() {
                return _ref6.apply(this, arguments);
            }

            return _delete;
        }()
        /**
         * Get the custom attributes of this Conversation.
         * @returns {Promise<any>} attributes of this Conversation
         */

    }, {
        key: "getAttributes",
        value: function () {
            var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
                return _regenerator2.default.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                _context7.next = 2;
                                return this._subscribe();

                            case 2:
                                return _context7.abrupt("return", this.attributes);

                            case 3:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));

            function getAttributes() {
                return _ref7.apply(this, arguments);
            }

            return getAttributes;
        }()
        /**
         * Returns messages from conversation using paginator interface.
         * @param {Number} [pageSize=30] Number of messages to return in single chunk
         * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
         * @param {('backwards'|'forward')} [direction=backwards] - Query direction. By default it query backwards
         *                                                          from newer to older. 'forward' will query in opposite direction
         * @returns {Promise<Paginator<Message>>} page of messages
         */

    }, {
        key: "getMessages",
        value: function () {
            var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(pageSize, anchor, direction) {
                return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                        switch (_context8.prev = _context8.next) {
                            case 0:
                                _context8.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context8.abrupt("return", this.messagesEntity.getMessages(pageSize, anchor, direction));

                            case 3:
                            case "end":
                                return _context8.stop();
                        }
                    }
                }, _callee8, this);
            }));

            function getMessages(_x7, _x8, _x9) {
                return _ref8.apply(this, arguments);
            }

            return getMessages;
        }()
        /**
         * Get a list of all Participants joined to this Conversation.
         * @returns {Promise<Participant[]>}
         */

    }, {
        key: "getParticipants",
        value: function () {
            var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
                return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                        switch (_context9.prev = _context9.next) {
                            case 0:
                                _context9.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context9.abrupt("return", this.participantsEntity.getParticipants());

                            case 3:
                            case "end":
                                return _context9.stop();
                        }
                    }
                }, _callee9, this);
            }));

            function getParticipants() {
                return _ref9.apply(this, arguments);
            }

            return getParticipants;
        }()
        /**
         * Get conversation participants count.
         * <br/>
         * This method is semi-realtime. This means that this data will be eventually correct,
         * but will also possibly be incorrect for a few seconds. The Conversation system does not
         * provide real time events for counter values changes.
         * <br/>
         * So this is quite useful for any UI badges, but is not recommended
         * to build any core application logic based on these counters being accurate in real time.
         * @returns {Promise<number>}
         */

    }, {
        key: "getParticipantsCount",
        value: function () {
            var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee10$(_context10) {
                    while (1) {
                        switch (_context10.prev = _context10.next) {
                            case 0:
                                _context10.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context10.sent;
                                url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
                                _context10.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context10.sent;
                                return _context10.abrupt("return", response.body.members_count);

                            case 8:
                            case "end":
                                return _context10.stop();
                        }
                    }
                }, _callee10, this);
            }));

            function getParticipantsCount() {
                return _ref10.apply(this, arguments);
            }

            return getParticipantsCount;
        }()
        /**
         * Get a Participant by its SID.
         * @param {String} participantSid - Participant sid
         * @returns {Promise<Participant>}
         */

    }, {
        key: "getParticipantBySid",
        value: function () {
            var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(participantSid) {
                return _regenerator2.default.wrap(function _callee11$(_context11) {
                    while (1) {
                        switch (_context11.prev = _context11.next) {
                            case 0:
                                return _context11.abrupt("return", this.participantsEntity.getParticipantBySid(participantSid));

                            case 1:
                            case "end":
                                return _context11.stop();
                        }
                    }
                }, _callee11, this);
            }));

            function getParticipantBySid(_x10) {
                return _ref11.apply(this, arguments);
            }

            return getParticipantBySid;
        }()
        /**
         * Get a Participant by its identity.
         * @param {String} identity - Participant identity
         * @returns {Promise<Participant>}
         */

    }, {
        key: "getParticipantByIdentity",
        value: function () {
            var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12(identity) {
                return _regenerator2.default.wrap(function _callee12$(_context12) {
                    while (1) {
                        switch (_context12.prev = _context12.next) {
                            case 0:
                                return _context12.abrupt("return", this.participantsEntity.getParticipantByIdentity(identity));

                            case 1:
                            case "end":
                                return _context12.stop();
                        }
                    }
                }, _callee12, this);
            }));

            function getParticipantByIdentity(_x11) {
                return _ref12.apply(this, arguments);
            }

            return getParticipantByIdentity;
        }()
        /**
         * Get total message count in a conversation.
         * <br/>
         * This method is semi-realtime. This means that this data will be eventually correct,
         * but will also possibly be incorrect for a few seconds. The Conversations system does not
         * provide real time events for counter values changes.
         * <br/>
         * So this is quite useful for any UI badges, but is not recommended
         * to build any core application logic based on these counters being accurate in real time.
         * @returns {Promise<number>}
         */

    }, {
        key: "getMessagesCount",
        value: function () {
            var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee13$(_context13) {
                    while (1) {
                        switch (_context13.prev = _context13.next) {
                            case 0:
                                _context13.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context13.sent;
                                url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
                                _context13.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context13.sent;
                                return _context13.abrupt("return", response.body.messages_count);

                            case 8:
                            case "end":
                                return _context13.stop();
                        }
                    }
                }, _callee13, this);
            }));

            function getMessagesCount() {
                return _ref13.apply(this, arguments);
            }

            return getMessagesCount;
        }()
        /**
         * Get unread messages count for the User if they are a Participant of this Conversation.
         * Rejects if the User is not a Participant of the Conversation.
         * <br/>
         * Use this method to obtain the number of unread messages together with
         * updateLastReadMessageIndex() instead of relying on the
         * Message indices which may have gaps. See Message.index for details.
         * <br/>
         * This method is semi-realtime. This means that this data will be eventually correct,
         * but will also possibly be incorrect for a few seconds. The Chat system does not
         * provide real time events for counter values changes.
         * <br/>
         * This is quite useful for any “unread messages count” badges, but is not recommended
         * to build any core application logic based on these counters being accurate in real time.
         * @returns {Promise<number|null>}
         */

    }, {
        key: "getUnreadMessagesCount",
        value: function () {
            var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee14$(_context14) {
                    while (1) {
                        switch (_context14.prev = _context14.next) {
                            case 0:
                                _context14.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context14.sent;
                                url = new util_1.UriBuilder(links.myChannelsUrl).arg('ChannelSid', this.sid).build();
                                _context14.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context14.sent;

                                if (!(response.body.channels.length && response.body.channels[0].channel_sid == this.sid)) {
                                    _context14.next = 11;
                                    break;
                                }

                                if (!(typeof response.body.channels[0].unread_messages_count !== 'undefined' && response.body.channels[0].unread_messages_count != null)) {
                                    _context14.next = 10;
                                    break;
                                }

                                return _context14.abrupt("return", response.body.channels[0].unread_messages_count);

                            case 10:
                                return _context14.abrupt("return", null);

                            case 11:
                                throw new Error('Conversation is not in user conversations list');

                            case 12:
                            case "end":
                                return _context14.stop();
                        }
                    }
                }, _callee14, this);
            }));

            function getUnreadMessagesCount() {
                return _ref14.apply(this, arguments);
            }

            return getUnreadMessagesCount;
        }()
        /**
         * Join the Conversation and subscribe to its events.
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "join",
        value: function () {
            var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15() {
                return _regenerator2.default.wrap(function _callee15$(_context15) {
                    while (1) {
                        switch (_context15.prev = _context15.next) {
                            case 0:
                                _context15.next = 2;
                                return this.services.session.addCommand('joinChannelV2', { channelSid: this.sid });

                            case 2:
                                return _context15.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context15.stop();
                        }
                    }
                }, _callee15, this);
            }));

            function join() {
                return _ref15.apply(this, arguments);
            }

            return join;
        }()
        /**
         * Leave the Conversation.
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "leave",
        value: function () {
            var _ref16 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee16() {
                return _regenerator2.default.wrap(function _callee16$(_context16) {
                    while (1) {
                        switch (_context16.prev = _context16.next) {
                            case 0:
                                if (!(this.channelState.status === 'joined')) {
                                    _context16.next = 3;
                                    break;
                                }

                                _context16.next = 3;
                                return this.services.session.addCommand('leaveChannel', { channelSid: this.sid });

                            case 3:
                                return _context16.abrupt("return", this);

                            case 4:
                            case "end":
                                return _context16.stop();
                        }
                    }
                }, _callee16, this);
            }));

            function leave() {
                return _ref16.apply(this, arguments);
            }

            return leave;
        }()
        /**
         * Remove a Participant from the Conversation. When a string is passed as the argument, it will assume that the string is an identity.
         * @param {String|Participant} participant - identity or participant object to remove
         * @returns {Promise<void>}
         */

    }, {
        key: "removeParticipant",
        value: function () {
            var _ref17 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee17(participant) {
                return _regenerator2.default.wrap(function _callee17$(_context17) {
                    while (1) {
                        switch (_context17.prev = _context17.next) {
                            case 0:
                                if (!(participant instanceof participant_1.Participant)) {
                                    _context17.next = 4;
                                    break;
                                }

                                _context17.next = 3;
                                return this.participantsEntity.removeBySid(participant.sid);

                            case 3:
                                return _context17.abrupt("return");

                            case 4:
                                _context17.next = 6;
                                return this.participantsEntity.removeByIdentity(participant);

                            case 6:
                            case "end":
                                return _context17.stop();
                        }
                    }
                }, _callee17, this);
            }));

            function removeParticipant(_x12) {
                return _ref17.apply(this, arguments);
            }

            return removeParticipant;
        }()
        /**
         * Send a Message in the Conversation.
         * @param {String|FormData|Conversation#SendMediaOptions|null} message - The message body for text message,
         * FormData or MediaOptions for media content. Sending FormData supported only with browser engine
         * @param {any} [messageAttributes] - attributes for the message
         * @param {Conversation#SendEmailOptions} [emailOptions] - email options for the message
         * @returns {Promise<number>} new Message's index in the Conversation's messages list
         */

    }, {
        key: "sendMessage",
        value: function () {
            var _ref18 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee18(message, messageAttributes, emailOptions) {
                var _response, response;

                return _regenerator2.default.wrap(function _callee18$(_context18) {
                    while (1) {
                        switch (_context18.prev = _context18.next) {
                            case 0:
                                if (!(typeof message === 'string' || message === null)) {
                                    _context18.next = 5;
                                    break;
                                }

                                _context18.next = 3;
                                return this.messagesEntity.send(message, messageAttributes, emailOptions);

                            case 3:
                                _response = _context18.sent;
                                return _context18.abrupt("return", util_1.parseToNumber(_response.messageId));

                            case 5:
                                _context18.next = 7;
                                return this.messagesEntity.sendMedia(message, messageAttributes, emailOptions);

                            case 7:
                                response = _context18.sent;
                                return _context18.abrupt("return", util_1.parseToNumber(response.messageId));

                            case 9:
                            case "end":
                                return _context18.stop();
                        }
                    }
                }, _callee18, this);
            }));

            function sendMessage(_x13, _x14, _x15) {
                return _ref18.apply(this, arguments);
            }

            return sendMessage;
        }()
        /**
         * Set last read Conversation's Message index to last known Message's index in this Conversation.
         * @returns {Promise<number>} resulting unread messages count in the conversation
         */

    }, {
        key: "setAllMessagesRead",
        value: function () {
            var _ref19 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee19() {
                var messagesPage;
                return _regenerator2.default.wrap(function _callee19$(_context19) {
                    while (1) {
                        switch (_context19.prev = _context19.next) {
                            case 0:
                                _context19.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                _context19.next = 4;
                                return this.getMessages(1);

                            case 4:
                                messagesPage = _context19.sent;

                                if (!(messagesPage.items.length > 0)) {
                                    _context19.next = 7;
                                    break;
                                }

                                return _context19.abrupt("return", this.advanceLastReadMessageIndex(messagesPage.items[0].index));

                            case 7:
                                return _context19.abrupt("return", _promise2.default.resolve(0));

                            case 8:
                            case "end":
                                return _context19.stop();
                        }
                    }
                }, _callee19, this);
            }));

            function setAllMessagesRead() {
                return _ref19.apply(this, arguments);
            }

            return setAllMessagesRead;
        }()
        /**
         * Set all messages in the conversation unread.
         * @returns {Promise<number>} resulting unread messages count in the conversation
         */

    }, {
        key: "setAllMessagesUnread",
        value: function () {
            var _ref20 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee20() {
                return _regenerator2.default.wrap(function _callee20$(_context20) {
                    while (1) {
                        switch (_context20.prev = _context20.next) {
                            case 0:
                                _context20.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context20.abrupt("return", this.services.readHorizon.updateLastReadMessageIndexForConversation(this.sid, null));

                            case 3:
                            case "end":
                                return _context20.stop();
                        }
                    }
                }, _callee20, this);
            }));

            function setAllMessagesUnread() {
                return _ref20.apply(this, arguments);
            }

            return setAllMessagesUnread;
        }()
        /**
         * Set User Notification level for this conversation.
         * @param {Conversation#NotificationLevel} notificationLevel - The new user notification level
         * @returns {Promise<void>}
         */

    }, {
        key: "setUserNotificationLevel",
        value: function () {
            var _ref21 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee21(notificationLevel) {
                return _regenerator2.default.wrap(function _callee21$(_context21) {
                    while (1) {
                        switch (_context21.prev = _context21.next) {
                            case 0:
                                _context21.next = 2;
                                return this.services.session.addCommand('editNotificationLevel', { channelSid: this.sid, notificationLevel: notificationLevel });

                            case 2:
                            case "end":
                                return _context21.stop();
                        }
                    }
                }, _callee21, this);
            }));

            function setUserNotificationLevel(_x16) {
                return _ref21.apply(this, arguments);
            }

            return setUserNotificationLevel;
        }()
        /**
         * Send a notification to the server indicating that this Client is currently typing in this Conversation.
         * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
         * @returns {Promise<void>}
         */

    }, {
        key: "typing",
        value: function typing() {
            return this.services.typingIndicator.send(this.sid);
        }
        /**
         * Update the Conversation's attributes.
         * @param {any} attributes - The new attributes object
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "updateAttributes",
        value: function () {
            var _ref22 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee22(attributes) {
                return _regenerator2.default.wrap(function _callee22$(_context22) {
                    while (1) {
                        switch (_context22.prev = _context22.next) {
                            case 0:
                                _context22.next = 2;
                                return this.services.session.addCommand('editAttributes', {
                                    channelSid: this.sid,
                                    attributes: (0, _stringify2.default)(attributes)
                                });

                            case 2:
                                return _context22.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context22.stop();
                        }
                    }
                }, _callee22, this);
            }));

            function updateAttributes(_x17) {
                return _ref22.apply(this, arguments);
            }

            return updateAttributes;
        }()
        /**
         * Update the Conversation's friendlyName.
         * @param {String|null} name - The new Conversation friendlyName
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "updateFriendlyName",
        value: function () {
            var _ref23 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee23(name) {
                return _regenerator2.default.wrap(function _callee23$(_context23) {
                    while (1) {
                        switch (_context23.prev = _context23.next) {
                            case 0:
                                if (!(this.channelState.friendlyName !== name)) {
                                    _context23.next = 3;
                                    break;
                                }

                                _context23.next = 3;
                                return this.services.session.addCommand('editFriendlyName', {
                                    channelSid: this.sid,
                                    friendlyName: name
                                });

                            case 3:
                                return _context23.abrupt("return", this);

                            case 4:
                            case "end":
                                return _context23.stop();
                        }
                    }
                }, _callee23, this);
            }));

            function updateFriendlyName(_x18) {
                return _ref23.apply(this, arguments);
            }

            return updateFriendlyName;
        }()
        /**
         * Set Conversation's last read Message index to current read horizon.
         * @param {Number|null} index - Message index to set as last read.
         * If null provided, then the behavior is identical to {@link Conversation#setAllMessagesUnread}
         * @returns {Promise<number>} resulting unread messages count in the conversation
         */

    }, {
        key: "updateLastReadMessageIndex",
        value: function () {
            var _ref24 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee24(index) {
                return _regenerator2.default.wrap(function _callee24$(_context24) {
                    while (1) {
                        switch (_context24.prev = _context24.next) {
                            case 0:
                                _context24.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context24.abrupt("return", this.services.readHorizon.updateLastReadMessageIndexForConversation(this.sid, index));

                            case 3:
                            case "end":
                                return _context24.stop();
                        }
                    }
                }, _callee24, this);
            }));

            function updateLastReadMessageIndex(_x19) {
                return _ref24.apply(this, arguments);
            }

            return updateLastReadMessageIndex;
        }()
        /**
         * Update the Conversation's unique name.
         * @param {String|null} uniqueName - New unique name for the Conversation. Setting unique name to null removes it.
         * @returns {Promise<Conversation>}
         */

    }, {
        key: "updateUniqueName",
        value: function () {
            var _ref25 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee25(uniqueName) {
                return _regenerator2.default.wrap(function _callee25$(_context25) {
                    while (1) {
                        switch (_context25.prev = _context25.next) {
                            case 0:
                                if (!(this.channelState.uniqueName !== uniqueName)) {
                                    _context25.next = 4;
                                    break;
                                }

                                if (!uniqueName) {
                                    uniqueName = '';
                                }
                                _context25.next = 4;
                                return this.services.session.addCommand('editUniqueName', {
                                    channelSid: this.sid,
                                    uniqueName: uniqueName
                                });

                            case 4:
                                return _context25.abrupt("return", this);

                            case 5:
                            case "end":
                                return _context25.stop();
                        }
                    }
                }, _callee25, this);
            }));

            function updateUniqueName(_x20) {
                return _ref25.apply(this, arguments);
            }

            return updateUniqueName;
        }()
    }, {
        key: "uniqueName",
        get: function get() {
            return this.channelState.uniqueName;
        }
    }, {
        key: "status",
        get: function get() {
            return this.channelState.status;
        }
    }, {
        key: "friendlyName",
        get: function get() {
            return this.channelState.friendlyName;
        }
    }, {
        key: "dateUpdated",
        get: function get() {
            return this.channelState.dateUpdated;
        }
    }, {
        key: "dateCreated",
        get: function get() {
            return this.channelState.dateCreated;
        }
    }, {
        key: "createdBy",
        get: function get() {
            return this.channelState.createdBy;
        }
    }, {
        key: "attributes",
        get: function get() {
            return this.channelState.attributes;
        }
    }, {
        key: "lastReadMessageIndex",
        get: function get() {
            return this.channelState.lastReadMessageIndex;
        }
    }, {
        key: "lastMessage",
        get: function get() {
            return this.channelState.lastMessage;
        }
    }, {
        key: "notificationLevel",
        get: function get() {
            return this.channelState.notificationLevel;
        }
    }, {
        key: "state",
        get: function get() {
            return this.channelState.state;
        }
    }], [{
        key: "preprocessUpdate",
        value: function preprocessUpdate(update, conversationSid) {
            try {
                if (typeof update.attributes === 'string') {
                    update.attributes = JSON.parse(update.attributes);
                } else if (update.attributes) {
                    (0, _stringify2.default)(update.attributes);
                }
            } catch (e) {
                log.warn('Retrieved malformed attributes from the server for conversation: ' + conversationSid);
                update.attributes = {};
            }
            try {
                if (update.dateCreated) {
                    update.dateCreated = new Date(update.dateCreated);
                }
            } catch (e) {
                log.warn('Retrieved malformed dateCreated from the server for conversation: ' + conversationSid);
                delete update.dateCreated;
            }
            try {
                if (update.dateUpdated) {
                    update.dateUpdated = new Date(update.dateUpdated);
                }
            } catch (e) {
                log.warn('Retrieved malformed dateUpdated from the server for conversation: ' + conversationSid);
                delete update.dateUpdated;
            }
            try {
                if (update.lastMessage && update.lastMessage.timestamp) {
                    update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
                }
            } catch (e) {
                log.warn('Retrieved malformed lastMessage.timestamp from the server for conversation: ' + conversationSid);
                delete update.lastMessage.timestamp;
            }
        }
    }]);
    return Conversation;
}(events_1.EventEmitter);

__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString, ['undefined', 'string', 'number', 'boolean', 'object', twilio_sdk_type_validator_1.literal(null)]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "add", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString, twilio_sdk_type_validator_1.nonEmptyString, ['undefined', 'object']), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String, Object]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "addNonChatParticipant", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "advanceLastReadMessageIndex", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(['undefined', twilio_sdk_type_validator_1.nonNegativeInteger], ['undefined', twilio_sdk_type_validator_1.nonNegativeInteger], ['undefined', twilio_sdk_type_validator_1.literal('backwards', 'forward')]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Number, String]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "getMessages", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "getParticipantBySid", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "getParticipantByIdentity", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync([twilio_sdk_type_validator_1.nonEmptyString, participant_1.Participant]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "removeParticipant", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(['string', twilio_sdk_type_validator_1.literal(null),
// Wrapping it into a custom rule is necessary because the FormData class is not available on initialization.
twilio_sdk_type_validator_1.custom(function (value) {
    return [value instanceof FormData, 'an instance of FormData'];
}), twilio_sdk_type_validator_1.objectSchema('media options', {
    contentType: twilio_sdk_type_validator_1.nonEmptyString,
    media: twilio_sdk_type_validator_1.custom(function (value) {
        var isValid = typeof value === 'string' && value.length > 0 || value instanceof Uint8Array || value instanceof ArrayBuffer;
        if (typeof Blob === 'function') {
            isValid = isValid || value instanceof Blob;
        }
        return [isValid, 'a non-empty string, an instance of Buffer or an instance of Blob'];
    })
})], ['undefined', 'string', 'number', 'boolean', 'object', twilio_sdk_type_validator_1.literal(null)], ['undefined', twilio_sdk_type_validator_1.literal(null), twilio_sdk_type_validator_1.objectSchema('email attributes', {
    subject: [twilio_sdk_type_validator_1.nonEmptyString, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object, Object]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "sendMessage", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.literal('default', 'muted')), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "setUserNotificationLevel", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(['string', 'number', 'boolean', 'object', twilio_sdk_type_validator_1.literal(null)]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "updateAttributes", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(['string', twilio_sdk_type_validator_1.literal(null)]), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "updateFriendlyName", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync([twilio_sdk_type_validator_1.literal(null), twilio_sdk_type_validator_1.nonNegativeInteger]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "updateLastReadMessageIndex", null);
__decorate([twilio_sdk_type_validator_1.validateTypesAsync(['string', twilio_sdk_type_validator_1.literal(null)]), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", _promise2.default)], Conversation.prototype, "updateUniqueName", null);
exports.Conversation = Conversation;
/**
 * Fired when a Participant has joined the Conversation.
 * @event Conversation#participantJoined
 * @type {Participant}
 */
/**
 * Fired when a Participant has left the Conversation.
 * @event Conversation#participantLeft
 * @type {Participant}
 */
/**
 * Fired when a Participant's fields has been updated.
 * @event Conversation#participantUpdated
 * @type {Object}
 * @property {Participant} participant - Updated Participant
 * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Conversation.
 * @event Conversation#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Conversation's message list.
 * @event Conversation#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Conversation#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when a Participant has stopped typing.
 * @event Conversation#typingEnded
 * @type {Participant}
 */
/**
 * Fired when a Participant has started typing.
 * @event Conversation#typingStarted
 * @type {Participant}
 */
/**
 * Fired when a Conversation's attributes or metadata have been updated.
 * @event Conversation#updated
 * @type {Object}
 * @property {Conversation} conversation - Updated Conversation
 * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons
 */
/**
 * Fired when the Conversation was destroyed or currently logged in User has left private Conversation
 * @event Conversation#removed
 * @type {Conversation}
 */