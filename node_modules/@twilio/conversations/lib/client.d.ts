/// <reference types="node" />
import { EventEmitter } from 'events';
import { User } from './user';
import { Transport } from './interfaces/transport';
import { Twilsock as TwilsockClient } from 'twilsock';
import { ChannelType, ConnectionState as NotificationConnectionState, Notifications as NotificationClient } from 'twilio-notifications';
import { SyncClient } from 'twilio-sync';
import { Conversation } from './data/conversations';
import { Paginator } from './interfaces/paginator';
import { PushNotification } from './pushnotification';
declare namespace Client {
    type ConnectionState = NotificationConnectionState;
    type NotificationsChannelType = ChannelType;
    type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent' | null;
    interface Options {
        region?: string;
        logLevel?: Client.LogLevel;
        productId?: string;
        twilsockClient?: TwilsockClient;
        transport?: Transport;
        notificationsClient?: NotificationClient;
        syncClient?: SyncClient;
        typingIndicatorTimeoutOverride?: number;
        consumptionReportIntervalOverride?: string;
        httpCacheIntervalOverride?: string;
        userInfosToSubscribeOverride?: number;
        retryWhenThrottledOverride?: boolean;
        backoffConfigOverride?: any;
        Chat?: any;
        Sync?: any;
        Notification?: any;
        Twilsock?: any;
        clientMetadata?: any;
    }
    interface CreateConversationOptions {
        attributes?: any;
        friendlyName?: string;
        uniqueName?: string;
    }
}
/**
 * A Client is a starting point to access Twilio Conversations functionality.
 *
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Conversations client
 *
 * @fires Client#connectionError
 * @fires Client#connectionStateChanged
 * @fires Client#conversationAdded
 * @fires Client#conversationJoined
 * @fires Client#conversationLeft
 * @fires Client#conversationRemoved
 * @fires Client#conversationUpdated
 * @fires Client#participantJoined
 * @fires Client#participantLeft
 * @fires Client#participantUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#tokenAboutToExpire
 * @fires Client#tokenExpired
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */
declare class Client extends EventEmitter {
    connectionState: Client.ConnectionState;
    private sessionPromise;
    private conversationsPromise;
    private fpaToken;
    private config;
    private conversations;
    private options;
    private services;
    static readonly version: string;
    readonly version: string;
    private static readonly supportedPushChannels;
    private static readonly supportedPushDataFields;
    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * These options can be passed to {@link Client#createConversation}.
     * @typedef {Object} Client#CreateConversationOptions
     * @property {any} [attributes] - Any custom attributes to attach to the Conversation
     * @property {String} [friendlyName] - The non-unique display name of the Conversation
     * @property {String} [uniqueName] - The unique identifier of the Conversation
     */
    /**
     * Connection state of Client.
     * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState
     */
    /**
     * Notifications channel type.
     * @typedef {('fcm'|'apn')} Client#NotificationsChannelType
     */
    private constructor();
    /**
     * Factory method to create Conversations client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} [options] - Options to customize the Client
     * @returns {Promise<Client>}
     */
    static create(token: string, options?: Client.Options): Promise<Client>;
    get user(): User;
    get reachabilityEnabled(): boolean;
    get token(): string;
    private subscribeToPushNotifications;
    private unsubscribeFromPushNotifications;
    private initialize;
    /**
     * Gracefully shutting down library instance.
     * @public
     * @returns {Promise<void>}
     */
    shutdown(): Promise<void>;
    /**
     * Update the token used by the Client and re-register with Conversations services.
     * @param {String} token - Access token
     * @public
     * @returns {Promise<Client>}
     */
    updateToken(token: string): Promise<Client>;
    /**
     * Get a known Conversation by its SID.
     * @param {String} conversationSid - Conversation sid
     * @returns {Promise<Conversation>}
     */
    getConversationBySid(conversationSid: string): Promise<Conversation>;
    /**
     * Get a known Conversation by its unique identifier name.
     * @param {String} uniqueName - The unique identifier name of the Conversation to get
     * @returns {Promise<Conversation>}
     */
    getConversationByUniqueName(uniqueName: string): Promise<Conversation>;
    /**
     * Get the current list of all subscribed Conversations.
     * @returns {Promise<Paginator<Conversation>>}
     */
    getSubscribedConversations(args?: any): Promise<Paginator<Conversation>>;
    /**
     * Create a Conversation on the server and subscribe to its events.
     * The default is a Conversation with an empty friendlyName.
     * @param {Client#CreateConversationOptions} [options] - Options for the Conversation
     * @returns {Promise<Conversation>}
     */
    createConversation(options?: Client.CreateConversationOptions): Promise<Conversation>;
    /**
     * Registers for push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported
     * @param {string} registrationId - Push notification id provided by the platform
     * @returns {Promise<void>}
     */
    setPushRegistrationId(channelType: Client.NotificationsChannelType, registrationId: string): Promise<void>;
    /**
     * Unregisters from push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported
     * @returns {Promise<void>}
     */
    unsetPushRegistrationId(channelType: Client.NotificationsChannelType): Promise<void>;
    private static parsePushNotificationChatData;
    /**
     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
     * @param {Object} notificationPayload - Push notification payload
     * @returns {PushNotification|Error}
     */
    static parsePushNotification(notificationPayload: any): PushNotification;
    parsePushNotification: typeof Client.parsePushNotification;
    /**
     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
     * @param {Object} notificationPayload - Push notification payload
     * @returns {Promise<void>}
     */
    handlePushNotification(notificationPayload: any): Promise<void>;
    /**
     * Gets user for given identity, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the subscribed list.
     * @param {String} identity - Identity of User
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string): Promise<User>;
    /**
     * @returns {Promise<Array<User>>} List of subscribed User objects
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
export { User, Client, PushNotification };
export default Client;
/**
 * Fired when a Conversation becomes visible to the Client. The event is also triggered when the client creates a new Conversation.
 * Fired for all conversations Client has joined.
 * @event Client#conversationAdded
 * @type {Conversation}
 */
/**
 * Fired when the Client joins a Conversation.
 * @event Client#conversationJoined
 * @type {Conversation}
 */
/**
 * Fired when the Client leaves a Conversation.
 * @event Client#conversationLeft
 * @type {Conversation}
 */
/**
 * Fired when a Conversation is no longer visible to the Client.
 * @event Client#conversationRemoved
 * @type {Conversation}
 */
/**
 * Fired when a Conversation's attributes or metadata have been updated.
 * During Conversation's {@link Client.create| creation and initialization} this event might be fired multiple times
 * for same joined or created Conversation as new data is arriving from different sources.
 * @event Client#conversationUpdated
 * @type {Object}
 * @property {Conversation} conversation - Updated Conversation
 * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons
 */
/**
 * Fired when Client's connection state has been changed.
 * @event Client#connectionStateChanged
 * @type {Client#ConnectionState}
 */
/**
 * Fired when a Participant has joined the Conversation.
 * @event Client#participantJoined
 * @type {Participant}
 */
/**
 * Fired when a Participant has left the Conversation.
 * @event Client#participantLeft
 * @type {Participant}
 */
/**
 * Fired when a Participant's fields has been updated.
 * @event Client#participantUpdated
 * @type {Object}
 * @property {Participant} participant - Updated Participant
 * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Conversation on the server.
 * @event Client#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Conversation's message list.
 * @event Client#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Client#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when token is about to expire and needs to be updated.
 * @event Client#tokenAboutToExpire
 * @type {void}
 */
/**
 * Fired when token is expired.
 * @event Client#tokenExpired
 * @type {void}
 */
/**
 * Fired when a Participant has stopped typing.
 * @event Client#typingEnded
 * @type {Participant}
 */
/**
 * Fired when a Participant has started typing.
 * @event Client#typingStarted
 * @type {Participant}
 */
/**
 * Fired when client received (and parsed) push notification via one of push channels (apn or fcm).
 * @event Client#pushNotification
 * @type {PushNotification}
 */
/**
 * Fired when the Client is subscribed to a User.
 * @event Client#userSubscribed
 * @type {User}
 */
/**
 * Fired when the Client is unsubscribed from a User.
 * @event Client#userUnsubscribed
 * @type {User}
 */
/**
 * Fired when the User's properties or reachability status have been updated.
 * @event Client#userUpdated
 * @type {Object}
 * @property {User} user - Updated User
 * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons
 */
/**
 * Fired when connection is interrupted by unexpected reason
 * @event Client#connectionError
 * @type {Object}
 * @property {Boolean} terminal - twilsock will stop connection attempts
 * @property {String} message - root cause
 * @property {Number} [httpStatusCode] - http status code if available
 * @property {Number} [errorCode] - Twilio public error code if available
 */
