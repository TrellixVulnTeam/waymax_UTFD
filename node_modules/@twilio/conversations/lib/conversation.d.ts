/// <reference types="node" />
import { EventEmitter } from 'events';
import { Participant } from './participant';
import { Message } from './message';
import { Users } from './data/users';
import { Paginator } from './interfaces/paginator';
import { Conversations } from './data/conversations';
import { McsClient } from 'twilio-mcs-client';
import { SyncClient } from 'twilio-sync';
import { Session } from './session';
import { ReadHorizon } from './services/readhorizon';
import { TypingIndicator } from './services/typingindicator';
import { Network } from './services/network';
export interface ConversationServices {
    session: Session;
    users: Users;
    typingIndicator: TypingIndicator;
    readHorizon: ReadHorizon;
    network: Network;
    mcsClient: McsClient;
    syncClient: SyncClient;
}
interface ConversationDescriptor {
    channel: string;
    entityName: string;
    uniqueName: string;
    attributes: any;
    createdBy?: string;
    friendlyName?: string;
    lastConsumedMessageIndex: number;
    dateCreated: any;
    dateUpdated: any;
    notificationLevel?: Conversation.NotificationLevel;
}
declare namespace Conversation {
    type UpdateReason = 'attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' | 'friendlyName' | 'lastReadMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' | 'notificationLevel';
    type Status = 'notParticipating' | 'joined';
    type NotificationLevel = 'default' | 'muted';
    type State = {
        current: 'active' | 'inactive' | 'closed';
        dateUpdated: Date;
    } | undefined;
    interface UpdatedEventArgs {
        conversation: Conversation;
        updateReasons: Conversation.UpdateReason[];
    }
    interface SendMediaOptions {
        contentType: string;
        media: string | Buffer;
    }
    interface SendEmailOptions {
        subject?: string;
    }
    interface LastMessage {
        index?: number;
        dateCreated?: Date;
    }
}
/**
 * @classdesc A Conversation represents communication between multiple Conversations Clients
 * @property {any} attributes - The Conversation's custom attributes
 * @property {String} createdBy - The identity of the User that created this Conversation
 * @property {Date} dateCreated - The Date this Conversation was created
 * @property {Date} dateUpdated - The Date this Conversation was last updated
 * @property {String} [friendlyName] - The Conversation's name
 * @property {Number|null} lastReadMessageIndex - Index of the last Message the User has read in this Conversation
 * @property {Conversation#LastMessage} lastMessage - Last Message sent to this Conversation
 * @property {Conversation#NotificationLevel} notificationLevel - User Notification level for this Conversation
 * @property {String} sid - The Conversation's unique system identifier
 * @property {Conversation#Status} status - The Conversation's status
 * @property {Conversation#State} state - The Conversation's state
 * @property {String} uniqueName - The Conversation's unique name
 * @fires Conversation#participantJoined
 * @fires Conversation#participantLeft
 * @fires Conversation#participantUpdated
 * @fires Conversation#messageAdded
 * @fires Conversation#messageRemoved
 * @fires Conversation#messageUpdated
 * @fires Conversation#typingEnded
 * @fires Conversation#typingStarted
 * @fires Conversation#updated
 * @fires Conversation#removed
 */
declare class Conversation extends EventEmitter {
    readonly sid: string;
    private services;
    private channelState;
    private statusSource;
    private entityPromise;
    private entityName;
    private entity;
    private messagesEntity;
    private participantsEntity;
    private participants;
    /**
     * These options can be passed to {@link Conversation#sendMessage}.
     * @typedef {Object} Conversation#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * These options can be passed to {@link Conversation#sendMessage}.
     * @typedef {Object} Conversation#SendEmailOptions
     * @property {String} subject - subject for the message. Ignored for media messages.
     */
    /**
     * The update reason for <code>updated</code> event emitted on Conversation
     * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |
      'friendlyName' | 'lastReadMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |
      'notificationLevel' )} Conversation#UpdateReason
     */
    /**
     * The status of the Conversation, relative to the Client: whether the Conversation has been <code>joined</code> or the Client is
     * <code>notParticipating</code> in the Conversation.
     * @typedef {('notParticipating' | 'joined')} Conversation#Status
     */
    /**
     * The User's Notification level for Conversation, determines whether the currently logged-in User will receive
     * pushes for events in this Conversation. Can be either <code>muted</code> or <code>default</code>,
     * where <code>default</code> defers to global Service push configuration.
     * @typedef {('default' | 'muted')} Conversation#NotificationLevel
     */
    /**
     * The Conversation's state.
     * @typedef {Object} Conversation#State
     * @property {('active' | 'inactive' | 'closed')} current - the current state
     * @property {Date} dateUpdated - date at which the latest conversation state update happened
     */
    constructor(services: ConversationServices, descriptor: ConversationDescriptor, sid: string);
    get uniqueName(): string;
    get status(): Conversation.Status;
    get friendlyName(): string;
    get dateUpdated(): any;
    get dateCreated(): any;
    get createdBy(): string;
    get attributes(): Object;
    get lastReadMessageIndex(): number | null;
    get lastMessage(): Conversation.LastMessage;
    get notificationLevel(): Conversation.NotificationLevel;
    get state(): Conversation.State;
    /**
     * The Conversation's last message's information.
     * @typedef {Object} Conversation#LastMessage
     * @property {Number} index - Message's index
     * @property {Date} dateCreated - Message's creation date
     */
    /**
     * Load and Subscribe to this Conversation and do not subscribe to its Participants and Messages.
     * This or _subscribeStreams will need to be called before any events on Conversation will fire.
     * @returns {Promise}
     * @private
     */
    _subscribe(): Promise<any>;
    /**
     * Load the attributes of this Conversation and instantiate its Participants and Messages.
     * This or _subscribe will need to be called before any events on Conversation will fire.
     * This will need to be called before any events on Participants or Messages will fire
     * @returns {Promise}
     * @private
     */
    _subscribeStreams(): Promise<void>;
    /**
     * Stop listening for and firing events on this Conversation.
     * @returns {Promise}
     * @private
     */
    _unsubscribe(): Promise<[void, any]>;
    /**
     * Set conversation status
     * @private
     */
    _setStatus(status: Conversation.Status, source: Conversations.DataSource): void;
    /**
     * If conversation's status update source
     * @private
     * @return {Conversations.DataSource}
     */
    _statusSource(): Conversations.DataSource;
    private static preprocessUpdate;
    /**
     * Updates local conversation object with new values
     * @private
     */
    _update(update: any): void;
    /**
     * @private
     */
    private _onMessageAdded;
    /**
     * Add a participant to the Conversation by its Identity.
     * @param {String} identity - Identity of the Client to add
     * @param {any} [attributes] Attributes to be attached to the participant
     * @returns {Promise<void>}
     */
    add(identity: string, attributes?: any): Promise<void>;
    /**
     * Add a non-chat participant to the Conversation.
     *
     * @param {String} proxyAddress Proxy (Twilio) address of the participant
     * @param {String} address User address of the participant
     * @param {any} [attributes] Attributes to be attached to the participant
     * @returns {Promise<void>}
     */
    addNonChatParticipant(proxyAddress: string, address: string, attributes?: Record<string, any>): Promise<any>;
    /**
     * Advance Conversation's last read Message index to current read horizon.
     * Rejects if User is not Participant of Conversation.
     * Last read Message index is updated only if new index value is higher than previous.
     * @param {Number} index - Message index to advance to as last read
     * @returns {Promise<number>} resulting unread messages count in the conversation
     */
    advanceLastReadMessageIndex(index: number): Promise<number>;
    /**
     * Delete the Conversation and unsubscribe from its events.
     * @returns {Promise<Conversation>}
     */
    delete(): Promise<Conversation>;
    /**
     * Get the custom attributes of this Conversation.
     * @returns {Promise<any>} attributes of this Conversation
     */
    getAttributes(): Promise<any>;
    /**
     * Returns messages from conversation using paginator interface.
     * @param {Number} [pageSize=30] Number of messages to return in single chunk
     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
     * @param {('backwards'|'forward')} [direction=backwards] - Query direction. By default it query backwards
     *                                                          from newer to older. 'forward' will query in opposite direction
     * @returns {Promise<Paginator<Message>>} page of messages
     */
    getMessages(pageSize?: number, anchor?: number, direction?: 'backwards' | 'forward'): Promise<Paginator<Message>>;
    /**
     * Get a list of all Participants joined to this Conversation.
     * @returns {Promise<Participant[]>}
     */
    getParticipants(): Promise<Participant[]>;
    /**
     * Get conversation participants count.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Conversation system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any UI badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number>}
     */
    getParticipantsCount(): Promise<number>;
    /**
     * Get a Participant by its SID.
     * @param {String} participantSid - Participant sid
     * @returns {Promise<Participant>}
     */
    getParticipantBySid(participantSid: string): Promise<Participant>;
    /**
     * Get a Participant by its identity.
     * @param {String} identity - Participant identity
     * @returns {Promise<Participant>}
     */
    getParticipantByIdentity(identity: string): Promise<Participant>;
    /**
     * Get total message count in a conversation.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Conversations system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any UI badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number>}
     */
    getMessagesCount(): Promise<number>;
    /**
     * Get unread messages count for the User if they are a Participant of this Conversation.
     * Rejects if the User is not a Participant of the Conversation.
     * <br/>
     * Use this method to obtain the number of unread messages together with
     * updateLastReadMessageIndex() instead of relying on the
     * Message indices which may have gaps. See Message.index for details.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Chat system does not
     * provide real time events for counter values changes.
     * <br/>
     * This is quite useful for any “unread messages count” badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number|null>}
     */
    getUnreadMessagesCount(): Promise<number | null>;
    /**
     * Join the Conversation and subscribe to its events.
     * @returns {Promise<Conversation>}
     */
    join(): Promise<Conversation>;
    /**
     * Leave the Conversation.
     * @returns {Promise<Conversation>}
     */
    leave(): Promise<Conversation>;
    /**
     * Remove a Participant from the Conversation. When a string is passed as the argument, it will assume that the string is an identity.
     * @param {String|Participant} participant - identity or participant object to remove
     * @returns {Promise<void>}
     */
    removeParticipant(participant: string | Participant): Promise<void>;
    /**
     * Send a Message in the Conversation.
     * @param {String|FormData|Conversation#SendMediaOptions|null} message - The message body for text message,
     * FormData or MediaOptions for media content. Sending FormData supported only with browser engine
     * @param {any} [messageAttributes] - attributes for the message
     * @param {Conversation#SendEmailOptions} [emailOptions] - email options for the message
     * @returns {Promise<number>} new Message's index in the Conversation's messages list
     */
    sendMessage(message: string | FormData | Conversation.SendMediaOptions | null, messageAttributes?: any, emailOptions?: Conversation.SendEmailOptions): Promise<number>;
    /**
     * Set last read Conversation's Message index to last known Message's index in this Conversation.
     * @returns {Promise<number>} resulting unread messages count in the conversation
     */
    setAllMessagesRead(): Promise<number>;
    /**
     * Set all messages in the conversation unread.
     * @returns {Promise<number>} resulting unread messages count in the conversation
     */
    setAllMessagesUnread(): Promise<number>;
    /**
     * Set User Notification level for this conversation.
     * @param {Conversation#NotificationLevel} notificationLevel - The new user notification level
     * @returns {Promise<void>}
     */
    setUserNotificationLevel(notificationLevel: Conversation.NotificationLevel): Promise<void>;
    /**
     * Send a notification to the server indicating that this Client is currently typing in this Conversation.
     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
     * @returns {Promise<void>}
     */
    typing(): Promise<void>;
    /**
     * Update the Conversation's attributes.
     * @param {any} attributes - The new attributes object
     * @returns {Promise<Conversation>}
     */
    updateAttributes(attributes: any): Promise<Conversation>;
    /**
     * Update the Conversation's friendlyName.
     * @param {String|null} name - The new Conversation friendlyName
     * @returns {Promise<Conversation>}
     */
    updateFriendlyName(name: string | null): Promise<Conversation>;
    /**
     * Set Conversation's last read Message index to current read horizon.
     * @param {Number|null} index - Message index to set as last read.
     * If null provided, then the behavior is identical to {@link Conversation#setAllMessagesUnread}
     * @returns {Promise<number>} resulting unread messages count in the conversation
     */
    updateLastReadMessageIndex(index: number | null): Promise<number>;
    /**
     * Update the Conversation's unique name.
     * @param {String|null} uniqueName - New unique name for the Conversation. Setting unique name to null removes it.
     * @returns {Promise<Conversation>}
     */
    updateUniqueName(uniqueName: string | null): Promise<Conversation>;
}
export { ConversationDescriptor, Conversation };
/**
 * Fired when a Participant has joined the Conversation.
 * @event Conversation#participantJoined
 * @type {Participant}
 */
/**
 * Fired when a Participant has left the Conversation.
 * @event Conversation#participantLeft
 * @type {Participant}
 */
/**
 * Fired when a Participant's fields has been updated.
 * @event Conversation#participantUpdated
 * @type {Object}
 * @property {Participant} participant - Updated Participant
 * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Conversation.
 * @event Conversation#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Conversation's message list.
 * @event Conversation#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Conversation#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when a Participant has stopped typing.
 * @event Conversation#typingEnded
 * @type {Participant}
 */
/**
 * Fired when a Participant has started typing.
 * @event Conversation#typingStarted
 * @type {Participant}
 */
/**
 * Fired when a Conversation's attributes or metadata have been updated.
 * @event Conversation#updated
 * @type {Object}
 * @property {Conversation} conversation - Updated Conversation
 * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons
 */
/**
 * Fired when the Conversation was destroyed or currently logged in User has left private Conversation
 * @event Conversation#removed
 * @type {Conversation}
 */
