/// <reference types="node" />
import { EventEmitter } from 'events';
import { Users } from './data/users';
import { User } from './user';
import { Session } from './session';
import { Conversation } from './conversation';
interface ParticipantDescriptor {
    attributes?: Object;
    dateCreated: any;
    dateUpdated: any;
    identity: string;
    roleSid?: string;
    lastConsumedMessageIndex: number;
    lastConsumptionTimestamp: number;
    type: Participant.Type;
    userInfo: string;
}
export interface ParticipantServices {
    users: Users;
    session: Session;
}
declare namespace Participant {
    type UpdateReason = 'attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' | 'lastReadMessageIndex' | 'lastReadTimestamp';
    type Type = 'chat' | 'sms' | 'whatsapp';
    interface UpdatedEventArgs {
        participant: Participant;
        updateReasons: Participant.UpdateReason[];
    }
}
/**
 * @classdesc A Participant represents a remote Client in a Conversation.
 * @property {any} attributes - Object with custom attributes for Participant
 * @property {Conversation} conversation - The Conversation the remote Client is a Participant of
 * @property {Date} dateCreated - The Date this Participant was created
 * @property {Date} dateUpdated - The Date this Participant was last updated
 * @property {String} identity - The identity of the remote Client
 * @property {Boolean} isTyping - Whether or not this Participant is currently typing
   * @property {Number|null} lastReadMessageIndex - Latest read Message index by this Participant.
 * Note that just retrieving messages on a client endpoint does not mean that messages are read,
 * please consider reading about [Read Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}
 * to find out how to mark messages as read.
 * @property {Date} lastReadTimestamp - Date when Participant has updated his read horizon
 * @property {String} sid - The server-assigned unique identifier for the Participant
 * @property {Participant#Type} type - The type of Participant
 * @fires Participant#typingEnded
 * @fires Participant#typingStarted
 * @fires Participant#updated
 */
declare class Participant extends EventEmitter {
    private state;
    private services;
    readonly conversation: Conversation;
    get sid(): string;
    get attributes(): Object;
    get dateCreated(): Date;
    get dateUpdated(): Date;
    get identity(): string;
    get isTyping(): boolean;
    get lastReadMessageIndex(): number | null;
    get lastReadTimestamp(): Date;
    get roleSid(): string;
    get type(): Participant.Type;
    /**
     * The update reason for <code>updated</code> event emitted on Participant
     * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |
      'lastReadMessageIndex' | 'lastReadTimestamp')} Participant#UpdateReason
     */
    /**
     * The type of Participant
     * @typedef {('chat' | 'sms' | 'whatsapp')} Participant#Type
     */
    constructor(services: ParticipantServices, conversation: Conversation, data: ParticipantDescriptor, sid: string);
    /**
     * Private method used to start or reset the typing indicator timeout (with event emitting)
     * @private
     */
    _startTyping(timeout: any): this;
    /**
     * Private method function used to stop typing indicator (with event emitting)
     * @private
     */
    _endTyping(): void;
    /**
     * Private method function used update local object's property roleSid with new value
     * @private
     */
    _update(data: any): this;
    /**
     * Gets User for this participant and subscribes to it. Supported only for <code>chat</code> type of Participants
     * @returns {Promise<User>}
     */
    getUser(): Promise<User>;
    /**
     * Remove Participant from the Conversation.
     * @returns {Promise<void>}
     */
    remove(): Promise<void>;
    /**
     * Edit participant attributes.
     * @param {any} attributes new attributes for Participant.
     * @returns {Promise<Participant>}
     */
    updateAttributes(attributes: any): Promise<Participant>;
}
export { ParticipantDescriptor, Participant };
/**
 * Fired when Participant started to type.
 * @event Participant#typingStarted
 * @type {Participant}
 */
/**
 * Fired when Participant ended to type.
 * @event Participant#typingEnded
 * @type {Participant}
 */
/**
 * Fired when Participant's fields has been updated.
 * @event Participant#updated
 * @type {Object}
 * @property {Participant} participant - Updated Participant
 * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons
 */
