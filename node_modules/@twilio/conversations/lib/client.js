"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const logger_1 = require("./logger");
const configuration_1 = require("./configuration");
const user_1 = require("./user");
exports.User = user_1.User;
const network_1 = require("./services/network");
const notificationtypes_1 = require("./interfaces/notificationtypes");
const synclist_1 = require("./synclist");
const twilsock_1 = require("twilsock");
const twilio_notifications_1 = require("twilio-notifications");
const twilio_sync_1 = require("twilio-sync");
const twilio_mcs_client_1 = require("twilio-mcs-client");
const session_1 = require("./session");
const conversations_1 = require("./data/conversations");
const users_1 = require("./data/users");
const typingindicator_1 = require("./services/typingindicator");
const readhorizon_1 = require("./services/readhorizon");
const pushnotification_1 = require("./pushnotification");
exports.PushNotification = pushnotification_1.PushNotification;
const util_1 = require("./util");
const telemetrytracker_1 = require("twilsock/lib/services/telemetrytracker");
const twilio_sdk_type_validator_1 = require("twilio-sdk-type-validator");
const log = logger_1.Logger.scope('Client');
const SDK_VERSION = require('./../package.json').version;
class ClientServices {
}
/**
 * A Client is a starting point to access Twilio Conversations functionality.
 *
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Conversations client
 *
 * @fires Client#connectionError
 * @fires Client#connectionStateChanged
 * @fires Client#conversationAdded
 * @fires Client#conversationJoined
 * @fires Client#conversationLeft
 * @fires Client#conversationRemoved
 * @fires Client#conversationUpdated
 * @fires Client#participantJoined
 * @fires Client#participantLeft
 * @fires Client#participantUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#tokenAboutToExpire
 * @fires Client#tokenExpired
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */
class Client extends events_1.EventEmitter {
    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * These options can be passed to {@link Client#createConversation}.
     * @typedef {Object} Client#CreateConversationOptions
     * @property {any} [attributes] - Any custom attributes to attach to the Conversation
     * @property {String} [friendlyName] - The non-unique display name of the Conversation
     * @property {String} [uniqueName] - The unique identifier of the Conversation
     */
    /**
     * Connection state of Client.
     * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState
     */
    /**
     * Notifications channel type.
     * @typedef {('fcm'|'apn')} Client#NotificationsChannelType
     */
    constructor(token, options) {
        super();
        this.connectionState = 'connecting';
        this.sessionPromise = null;
        this.conversationsPromise = null;
        this.version = SDK_VERSION;
        this.parsePushNotification = Client.parsePushNotification;
        this.options = (options || {});
        if (!this.options.disableDeepClone) {
            let options = Object.assign(Object.assign({}, this.options), { transport: undefined, twilsockClient: undefined });
            options = util_1.deepClone(options);
            options.transport = this.options.transport;
            options.twilsockClient = this.options.twilsockClient;
            this.options = options;
        }
        this.options.logLevel = this.options.logLevel || 'silent';
        log.setLevel(this.options.logLevel);
        const productId = this.options.productId = 'ip_messaging';
        // Filling ClientMetadata
        this.options.clientMetadata = this.options.clientMetadata || {};
        if (!this.options.clientMetadata.hasOwnProperty('type')) {
            this.options.clientMetadata.type = 'conversations';
        }
        if (!this.options.clientMetadata.hasOwnProperty('sdk')) {
            this.options.clientMetadata.sdk = 'JS';
            this.options.clientMetadata.sdkv = SDK_VERSION;
        }
        // Enable session local storage for Sync
        this.options.Sync = this.options.Sync || {};
        if (typeof this.options.Sync.enableSessionStorage === 'undefined') {
            this.options.Sync.enableSessionStorage = true;
        }
        if (this.options.region) {
            this.options.Sync.region = this.options.region;
        }
        if (!token) {
            throw new Error('A valid Twilio token should be provided');
        }
        this.services = new ClientServices();
        this.config = new configuration_1.Configuration(this.options);
        this.options.twilsockClient = this.options.twilsockClient || new twilsock_1.Twilsock(token, productId, this.options);
        this.options.transport = this.options.transport || this.options.twilsockClient;
        this.options.notificationsClient = this.options.notificationsClient || new twilio_notifications_1.Notifications(token, this.options);
        this.options.syncClient = this.options.syncClient || new twilio_sync_1.SyncClient(token, this.options);
        this.services.syncClient = this.options.syncClient;
        this.services.transport = this.options.transport;
        this.services.twilsockClient = this.options.twilsockClient;
        this.services.notificationClient = this.options.notificationsClient;
        this.services.session = new session_1.Session(this.services, this.config);
        this.sessionPromise = this.services.session.initialize();
        this.services.network = new network_1.Network(this.config, this.services);
        this.services.users = new users_1.Users({
            session: this.services.session,
            network: this.services.network,
            syncClient: this.services.syncClient
        });
        this.services.users.on('userSubscribed', this.emit.bind(this, 'userSubscribed'));
        this.services.users.on('userUpdated', (args) => this.emit('userUpdated', args));
        this.services.users.on('userUnsubscribed', this.emit.bind(this, 'userUnsubscribed'));
        this.services.twilsockClient.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));
        this.services.twilsockClient.on('tokenExpired', () => this.emit('tokenExpired'));
        this.services.twilsockClient.on('connectionError', (error) => this.emit('connectionError', error));
        this.services.readHorizon = new readhorizon_1.ReadHorizon(this.services);
        this.services.typingIndicator = new typingindicator_1.TypingIndicator(this.config, {
            transport: this.services.twilsockClient,
            notificationClient: this.services.notificationClient
        }, this.getConversationBySid.bind(this));
        this.services.syncList = new synclist_1.SyncList(this.services);
        this.conversations = new conversations_1.Conversations(this.services);
        this.conversationsPromise = this.sessionPromise.then(() => {
            this.conversations.on('conversationAdded', this.emit.bind(this, 'conversationAdded'));
            this.conversations.on('conversationRemoved', this.emit.bind(this, 'conversationRemoved'));
            this.conversations.on('conversationJoined', this.emit.bind(this, 'conversationJoined'));
            this.conversations.on('conversationLeft', this.emit.bind(this, 'conversationLeft'));
            this.conversations.on('conversationUpdated', (args) => this.emit('conversationUpdated', args));
            this.conversations.on('participantJoined', this.emit.bind(this, 'participantJoined'));
            this.conversations.on('participantLeft', this.emit.bind(this, 'participantLeft'));
            this.conversations.on('participantUpdated', (args) => this.emit('participantUpdated', args));
            this.conversations.on('messageAdded', this.emit.bind(this, 'messageAdded'));
            this.conversations.on('messageUpdated', (args) => this.emit('messageUpdated', args));
            this.conversations.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
            this.conversations.on('typingStarted', this.emit.bind(this, 'typingStarted'));
            this.conversations.on('typingEnded', this.emit.bind(this, 'typingEnded'));
            return this.conversations.fetchConversations();
        }).then(() => this.conversations);
        this.services.notificationClient.on('connectionStateChanged', (state) => {
            let changedConnectionState = null;
            switch (state) {
                case 'connected':
                    changedConnectionState = 'connected';
                    break;
                case 'denied':
                    changedConnectionState = 'denied';
                    break;
                case 'disconnecting':
                    changedConnectionState = 'disconnecting';
                    break;
                case 'disconnected':
                    changedConnectionState = 'disconnected';
                    break;
                default:
                    changedConnectionState = 'connecting';
            }
            if (changedConnectionState !== this.connectionState) {
                this.connectionState = changedConnectionState;
                this.emit('connectionStateChanged', this.connectionState);
            }
        });
        this.fpaToken = token;
    }
    /**
     * Factory method to create Conversations client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} [options] - Options to customize the Client
     * @returns {Promise<Client>}
     */
    static async create(token, options) {
        let client = new Client(token, options);
        const startupEvent = 'conversations.client.startup';
        client.services.twilsockClient.addPartialTelemetryEvent(new telemetrytracker_1.TelemetryEventDescription(startupEvent, 'Conversations client startup', new Date()), startupEvent, telemetrytracker_1.TelemetryPoint.Start);
        await client.initialize();
        client.services.twilsockClient.addPartialTelemetryEvent(new telemetrytracker_1.TelemetryEventDescription('', '', new Date()), startupEvent, telemetrytracker_1.TelemetryPoint.End);
        return client;
    }
    get user() { return this.services.users.myself; }
    get reachabilityEnabled() { return this.services.session.reachabilityEnabled; }
    get token() { return this.fpaToken; }
    subscribeToPushNotifications(channelType) {
        let subscriptions = [];
        [notificationtypes_1.NotificationTypes.NEW_MESSAGE,
            notificationtypes_1.NotificationTypes.ADDED_TO_CONVERSATION,
            notificationtypes_1.NotificationTypes.REMOVED_FROM_CONVERSATION,
            notificationtypes_1.NotificationTypes.TYPING_INDICATOR,
            notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE]
            .forEach(messageType => {
            subscriptions.push(this.services.notificationClient.subscribe(messageType, channelType));
        });
        return Promise.all(subscriptions);
    }
    unsubscribeFromPushNotifications(channelType) {
        let subscriptions = [];
        [notificationtypes_1.NotificationTypes.NEW_MESSAGE,
            notificationtypes_1.NotificationTypes.ADDED_TO_CONVERSATION,
            notificationtypes_1.NotificationTypes.REMOVED_FROM_CONVERSATION,
            notificationtypes_1.NotificationTypes.TYPING_INDICATOR,
            notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE]
            .forEach(messageType => {
            subscriptions.push(this.services.notificationClient.unsubscribe(messageType, channelType));
        });
        return Promise.all(subscriptions);
    }
    async initialize() {
        await this.sessionPromise;
        Client.supportedPushChannels.forEach(channelType => this.subscribeToPushNotifications(channelType));
        let links = await this.services.session.getSessionLinks();
        let options = Object.assign(this.options);
        options.transport = null;
        this.services.mcsClient = new twilio_mcs_client_1.McsClient(this.fpaToken, links.mediaServiceUrl, options);
        await this.services.typingIndicator.initialize();
    }
    /**
     * Gracefully shutting down library instance.
     * @public
     * @returns {Promise<void>}
     */
    async shutdown() {
        await this.services.twilsockClient.disconnect();
    }
    /**
     * Update the token used by the Client and re-register with Conversations services.
     * @param {String} token - Access token
     * @public
     * @returns {Promise<Client>}
     */
    async updateToken(token) {
        log.info('updateToken');
        if (this.fpaToken === token) {
            return this;
        }
        await this.services.twilsockClient.updateToken(token)
            .then(() => this.fpaToken = token)
            .then(() => this.services.mcsClient.updateToken(token))
            .then(() => this.sessionPromise);
        return this;
    }
    /**
     * Get a known Conversation by its SID.
     * @param {String} conversationSid - Conversation sid
     * @returns {Promise<Conversation>}
     */
    async getConversationBySid(conversationSid) {
        await this.conversations.syncListRead.promise;
        let conversation = await this.conversations.getConversation(conversationSid);
        if (!conversation) {
            conversation = await this.conversations.getWhisperConversation(conversationSid);
        }
        if (!conversation) {
            throw new Error(`Conversation with SID ${conversationSid} is not found.`);
        }
        return conversation;
    }
    /**
     * Get a known Conversation by its unique identifier name.
     * @param {String} uniqueName - The unique identifier name of the Conversation to get
     * @returns {Promise<Conversation>}
     */
    async getConversationByUniqueName(uniqueName) {
        await this.conversations.syncListRead.promise;
        const conversation = await this.conversations.getConversationByUniqueName(uniqueName);
        if (!conversation) {
            throw new Error(`Conversation with unique name ${uniqueName} is not found.`);
        }
        return conversation;
    }
    /**
     * Get the current list of all subscribed Conversations.
     * @returns {Promise<Paginator<Conversation>>}
     */
    getSubscribedConversations(args) {
        return this.conversationsPromise.then(conversations => conversations.getConversations(args));
    }
    /**
     * Create a Conversation on the server and subscribe to its events.
     * The default is a Conversation with an empty friendlyName.
     * @param {Client#CreateConversationOptions} [options] - Options for the Conversation
     * @returns {Promise<Conversation>}
     */
    createConversation(options) {
        options = options || {};
        return this.conversationsPromise.then(conversationsEntity => conversationsEntity.addConversation(options));
    }
    /**
     * Registers for push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported
     * @param {string} registrationId - Push notification id provided by the platform
     * @returns {Promise<void>}
     */
    async setPushRegistrationId(channelType, registrationId) {
        await this.subscribeToPushNotifications(channelType)
            .then(() => {
            return this.services.notificationClient.setPushRegistrationId(registrationId, channelType);
        });
    }
    /**
     * Unregisters from push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'apn' and 'fcm' are supported
     * @returns {Promise<void>}
     */
    async unsetPushRegistrationId(channelType) {
        if (Client.supportedPushChannels.indexOf(channelType) === -1) {
            throw new Error('Invalid or unsupported channelType: ' + channelType);
        }
        await this.unsubscribeFromPushNotifications(channelType);
    }
    static parsePushNotificationChatData(data) {
        let result = {};
        for (let key in Client.supportedPushDataFields) {
            if (typeof data[key] !== 'undefined' && data[key] !== null) {
                if (key === 'message_index') {
                    if (util_1.parseToNumber(data[key]) !== null) {
                        result[Client.supportedPushDataFields[key]] = Number(data[key]);
                    }
                }
                else {
                    result[Client.supportedPushDataFields[key]] = data[key];
                }
            }
        }
        return result;
    }
    /**
     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
     * @param {Object} notificationPayload - Push notification payload
     * @returns {PushNotification|Error}
     */
    static parsePushNotification(notificationPayload) {
        log.debug('parsePushNotification, notificationPayload=', notificationPayload);
        // APNS specifics
        if (typeof notificationPayload.aps !== 'undefined') {
            if (!notificationPayload.twi_message_type) {
                throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
            }
            let data = Client.parsePushNotificationChatData(notificationPayload);
            let apsPayload = notificationPayload.aps;
            let body = null;
            let title = null;
            if (typeof apsPayload.alert === 'string') {
                body = apsPayload.alert || null;
            }
            else {
                body = apsPayload.alert.body || null;
                title = apsPayload.alert.title || null;
            }
            return new pushnotification_1.PushNotification({
                title: title,
                body: body,
                sound: apsPayload.sound || null,
                badge: apsPayload.badge || null,
                action: apsPayload.category || null,
                type: notificationPayload.twi_message_type,
                data: data
            });
        }
        // FCM specifics
        if (typeof notificationPayload.data !== 'undefined') {
            let dataPayload = notificationPayload.data;
            if (!dataPayload.twi_message_type) {
                throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
            }
            let data = Client.parsePushNotificationChatData(notificationPayload.data);
            return new pushnotification_1.PushNotification({
                title: dataPayload.twi_title || null,
                body: dataPayload.twi_body || null,
                sound: dataPayload.twi_sound || null,
                badge: null,
                action: dataPayload.twi_action || null,
                type: dataPayload.twi_message_type,
                data: data
            });
        }
        throw new Error('Provided push notification payload is not Programmable Chat notification');
    }
    /**
     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
     * @param {Object} notificationPayload - Push notification payload
     * @returns {Promise<void>}
     */
    async handlePushNotification(notificationPayload) {
        log.debug('handlePushNotification, notificationPayload=', notificationPayload);
        this.emit('pushNotification', Client.parsePushNotification(notificationPayload));
    }
    /**
     * Gets user for given identity, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the subscribed list.
     * @param {String} identity - Identity of User
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity) {
        return this.services.users.getUser(identity);
    }
    /**
     * @returns {Promise<Array<User>>} List of subscribed User objects
     */
    async getSubscribedUsers() {
        return this.services.users.getSubscribedUsers();
    }
}
Client.version = SDK_VERSION;
Client.supportedPushChannels = ['fcm', 'apn'];
Client.supportedPushDataFields = {
    'conversation_sid': 'conversationSid',
    'message_sid': 'messageSid',
    'message_index': 'messageIndex'
};
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "updateToken", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "getConversationBySid", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "getConversationByUniqueName", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync([
        'undefined',
        twilio_sdk_type_validator_1.objectSchema('conversation options', {
            friendlyName: ['string', 'undefined'],
            isPrivate: ['boolean', 'undefined'],
            uniqueName: ['string', 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Client.prototype, "createConversation", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.literal('fcm', 'apn'), 'string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "setPushRegistrationId", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.literal('fcm', 'apn')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "unsetPushRegistrationId", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.pureObject),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Client.prototype, "handlePushNotification", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync(twilio_sdk_type_validator_1.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "getUser", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync('string', ['undefined', twilio_sdk_type_validator_1.pureObject]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], Client, "create", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypes(twilio_sdk_type_validator_1.pureObject),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", pushnotification_1.PushNotification)
], Client, "parsePushNotification", null);
exports.Client = Client;
exports.default = Client;
/**
 * Fired when a Conversation becomes visible to the Client. The event is also triggered when the client creates a new Conversation.
 * Fired for all conversations Client has joined.
 * @event Client#conversationAdded
 * @type {Conversation}
 */
/**
 * Fired when the Client joins a Conversation.
 * @event Client#conversationJoined
 * @type {Conversation}
 */
/**
 * Fired when the Client leaves a Conversation.
 * @event Client#conversationLeft
 * @type {Conversation}
 */
/**
 * Fired when a Conversation is no longer visible to the Client.
 * @event Client#conversationRemoved
 * @type {Conversation}
 */
/**
 * Fired when a Conversation's attributes or metadata have been updated.
 * During Conversation's {@link Client.create| creation and initialization} this event might be fired multiple times
 * for same joined or created Conversation as new data is arriving from different sources.
 * @event Client#conversationUpdated
 * @type {Object}
 * @property {Conversation} conversation - Updated Conversation
 * @property {Conversation#UpdateReason[]} updateReasons - Array of Conversation's updated event reasons
 */
/**
 * Fired when Client's connection state has been changed.
 * @event Client#connectionStateChanged
 * @type {Client#ConnectionState}
 */
/**
 * Fired when a Participant has joined the Conversation.
 * @event Client#participantJoined
 * @type {Participant}
 */
/**
 * Fired when a Participant has left the Conversation.
 * @event Client#participantLeft
 * @type {Participant}
 */
/**
 * Fired when a Participant's fields has been updated.
 * @event Client#participantUpdated
 * @type {Object}
 * @property {Participant} participant - Updated Participant
 * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Conversation on the server.
 * @event Client#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Conversation's message list.
 * @event Client#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Client#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when token is about to expire and needs to be updated.
 * @event Client#tokenAboutToExpire
 * @type {void}
 */
/**
 * Fired when token is expired.
 * @event Client#tokenExpired
 * @type {void}
 */
/**
 * Fired when a Participant has stopped typing.
 * @event Client#typingEnded
 * @type {Participant}
 */
/**
 * Fired when a Participant has started typing.
 * @event Client#typingStarted
 * @type {Participant}
 */
/**
 * Fired when client received (and parsed) push notification via one of push channels (apn or fcm).
 * @event Client#pushNotification
 * @type {PushNotification}
 */
/**
 * Fired when the Client is subscribed to a User.
 * @event Client#userSubscribed
 * @type {User}
 */
/**
 * Fired when the Client is unsubscribed from a User.
 * @event Client#userUnsubscribed
 * @type {User}
 */
/**
 * Fired when the User's properties or reachability status have been updated.
 * @event Client#userUpdated
 * @type {Object}
 * @property {User} user - Updated User
 * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons
 */
/**
 * Fired when connection is interrupted by unexpected reason
 * @event Client#connectionError
 * @type {Object}
 * @property {Boolean} terminal - twilsock will stop connection attempts
 * @property {String} message - root cause
 * @property {Number} [httpStatusCode] - http status code if available
 * @property {Number} [errorCode] - Twilio public error code if available
 */
