"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const util_1 = require("./util");
const logger_1 = require("./logger");
const media_1 = require("./media");
const aggregateddeliveryreceipt_1 = require("./aggregateddeliveryreceipt");
const twilio_sdk_type_validator_1 = require("twilio-sdk-type-validator");
const restpaginator_1 = require("./restpaginator");
const detaileddeliveryreceipt_1 = require("./detaileddeliveryreceipt");
const log = logger_1.Logger.scope('Message');
/**
 * @classdesc A Message represents a Message in a Conversation.
 * @property {String} author - The name of the user that sent Message
 * @property {String|null} subject - Message subject. Used only in email conversations
 * @property {String} body - The body of the Message. Is null if Message is Media Message
 * @property {any} attributes - Message custom attributes
 * @property {Conversation} conversation - Conversation Message belongs to
 * @property {Date} dateCreated - When Message was created
 * @property {Date} dateUpdated - When Message was updated
 * @property {Number} index - Index of Message in the Conversation's messages list
 *  By design of the conversations system the message indices may have arbitrary gaps between them,
 *  that does not necessarily mean they were deleted or otherwise modified - just that
 *  messages may have non-contiguous indices even if they are sent immediately one after another.
 *
 *  Trying to use indices for some calculations is going to be unreliable.
 *
 *  To calculate the number of unread messages it is better to use the read horizon API.
 *  See {@link Conversation#getUnreadMessagesCount} for details.
 *
 * @property {String} lastUpdatedBy - Identity of the last user that updated Message
 * @property {Media} media - Contains Media information (if present)
 * @property {String} participantSid - Authoring Participant's server-assigned unique identifier
 * @property {String} sid - The server-assigned unique identifier for Message
 * @property {'text' | 'media'} type - Type of message: 'text' or 'media'
 * @property {AggregatedDeliveryReceipt | null} aggregatedDeliveryReceipt - Aggregated information about
 *   Message delivery statuses across all {@link Participant}s of a {@link Conversation}.
 * @fires Message#updated
 */
class Message extends events_1.EventEmitter {
    /**
     * The update reason for <code>updated</code> event emitted on Message
     * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author' |
     *   'deliveryReceipt' | 'subject')} Message#UpdateReason
     */
    constructor(conversation, services, index, data) {
        super();
        this.conversation = conversation;
        this.services = services;
        this.state = {
            sid: data.sid,
            index: index,
            author: data.author == null ? null : data.author,
            subject: data.subject == null ? null : data.subject,
            body: data.text,
            timestamp: data.timestamp ? new Date(data.timestamp) : null,
            dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,
            lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,
            attributes: util_1.parseAttributes(data.attributes, `Got malformed attributes for the message ${data.sid}`, log),
            type: data.type ? data.type : 'text',
            media: (data.type && data.type === 'media' && data.media)
                ? new media_1.Media(data.media, this.services) : null,
            participantSid: data.memberSid == null ? null : data.memberSid,
            aggregatedDeliveryReceipt: data.delivery ? new aggregateddeliveryreceipt_1.AggregatedDeliveryReceipt(data.delivery) : null
        };
    }
    get sid() { return this.state.sid; }
    get author() { return this.state.author; }
    get subject() { return this.state.subject; }
    get body() {
        if (this.type === 'media') {
            return null;
        }
        return this.state.body;
    }
    get dateUpdated() { return this.state.dateUpdated; }
    get index() { return this.state.index; }
    get lastUpdatedBy() { return this.state.lastUpdatedBy; }
    get dateCreated() { return this.state.timestamp; }
    get attributes() { return this.state.attributes; }
    get type() { return this.state.type; }
    get media() { return this.state.media; }
    get participantSid() { return this.state.participantSid; }
    get aggregatedDeliveryReceipt() { return this.state.aggregatedDeliveryReceipt; }
    _update(data) {
        let updateReasons = [];
        if ((data.text || ((typeof data.text) === 'string')) && data.text !== this.state.body) {
            this.state.body = data.text;
            updateReasons.push('body');
        }
        if (data.subject && data.subject !== this.state.subject) {
            this.state.subject = data.subject;
            updateReasons.push('subject');
        }
        if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {
            this.state.lastUpdatedBy = data.lastUpdatedBy;
            updateReasons.push('lastUpdatedBy');
        }
        if (data.author && data.author !== this.state.author) {
            this.state.author = data.author;
            updateReasons.push('author');
        }
        if (data.dateUpdated &&
            new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
            this.state.dateUpdated = new Date(data.dateUpdated);
            updateReasons.push('dateUpdated');
        }
        if (data.timestamp &&
            new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {
            this.state.timestamp = new Date(data.timestamp);
            updateReasons.push('dateCreated');
        }
        let updatedAttributes = util_1.parseAttributes(data.attributes, `Got malformed attributes for the message ${this.sid}`, log);
        if (!util_1.isDeepEqual(this.state.attributes, updatedAttributes)) {
            this.state.attributes = updatedAttributes;
            updateReasons.push('attributes');
        }
        let updatedAggregatedDelivery = data.delivery;
        let currentAggregatedDelivery = this.state.aggregatedDeliveryReceipt;
        let isUpdatedAggregateDeliveryValid = !!updatedAggregatedDelivery && !!updatedAggregatedDelivery.total &&
            !!updatedAggregatedDelivery.delivered && !!updatedAggregatedDelivery.failed && !!updatedAggregatedDelivery.read &&
            !!updatedAggregatedDelivery.sent && !!updatedAggregatedDelivery.undelivered;
        if (isUpdatedAggregateDeliveryValid) {
            if (!currentAggregatedDelivery) {
                this.state.aggregatedDeliveryReceipt = new aggregateddeliveryreceipt_1.AggregatedDeliveryReceipt(updatedAggregatedDelivery);
                updateReasons.push('deliveryReceipt');
            }
            else if (!currentAggregatedDelivery._isEquals(updatedAggregatedDelivery)) {
                currentAggregatedDelivery._update(updatedAggregatedDelivery);
                updateReasons.push('deliveryReceipt');
            }
        }
        if (updateReasons.length > 0) {
            this.emit('updated', { message: this, updateReasons: updateReasons });
        }
    }
    /**
     * Get Participant who is author of the Message
     * @returns {Promise<Participant>}
     */
    async getParticipant() {
        let participant = null;
        if (this.state.participantSid) {
            participant = await this.conversation.getParticipantBySid(this.participantSid)
                .catch(() => {
                log.debug('Participant with sid "' + this.participantSid + '" not found for message ' + this.sid);
                return null;
            });
        }
        if (!participant && this.state.author) {
            participant = await this.conversation.getParticipantByIdentity(this.state.author)
                .catch(() => {
                log.debug('Participant with identity "' + this.author + '" not found for message ' + this.sid);
                return null;
            });
        }
        if (participant) {
            return participant;
        }
        let errorMesage = 'Participant with ';
        if (this.state.participantSid) {
            errorMesage += 'SID \'' + this.state.participantSid + '\' ';
        }
        if (this.state.author) {
            if (this.state.participantSid) {
                errorMesage += 'or ';
            }
            errorMesage += 'identity \'' + this.state.author + '\' ';
        }
        if (errorMesage === 'Participant with ') {
            errorMesage = 'Participant ';
        }
        errorMesage += 'was not found';
        throw new Error(errorMesage);
    }
    /**
     * Get delivery receipts of the message
     * @returns {Promise<DetailedDeliveryReceipt[]>}
     */
    async getDetailedDeliveryReceipts() {
        let paginator = await this._getDetailedDeliveryReceiptsPaginator();
        let detailedDeliveryReceipts = [];
        while (true) {
            detailedDeliveryReceipts = [...detailedDeliveryReceipts, ...paginator.items];
            if (!paginator.hasNextPage) {
                break;
            }
            paginator = await paginator.nextPage();
        }
        return detailedDeliveryReceipts;
    }
    /**
     * Remove the Message.
     * @returns {Promise<Message>}
     */
    async remove() {
        await this.services.session.addCommand('deleteMessage', {
            channelSid: this.conversation.sid,
            messageIdx: this.index.toString()
        });
        return this;
    }
    /**
     * Edit message body.
     * @param {String} body - new body of Message.
     * @returns {Promise<Message>}
     */
    async updateBody(body) {
        await this.services.session.addCommand('editMessage', {
            channelSid: this.conversation.sid,
            messageIdx: this.index.toString(),
            text: body
        });
        return this;
    }
    /**
     * Edit message attributes.
     * @param {any} attributes new attributes for Message.
     * @returns {Promise<Message>}
     */
    async updateAttributes(attributes) {
        await this.services.session.addCommand('editMessageAttributes', {
            channelSid: this.conversation.sid,
            messageIdx: this.index,
            attributes: JSON.stringify(attributes)
        });
        return this;
    }
    async _getDetailedDeliveryReceiptsPaginator(options) {
        var _a, _b;
        let links = await this.services.session.getSessionLinks();
        let messagesReceiptsUrl = links.messagesReceiptsUrl.replace('%s', this.conversation.sid).replace('%s', this.sid);
        let url = new util_1.UriBuilder(messagesReceiptsUrl).arg('PageToken', (_a = options) === null || _a === void 0 ? void 0 : _a.pageToken).arg('PageSize', (_b = options) === null || _b === void 0 ? void 0 : _b.pageSize).build();
        let response = await this.services.network.get(url);
        return new restpaginator_1.RestPaginator(response.body.delivery_receipts.map(x => new detaileddeliveryreceipt_1.DetailedDeliveryReceipt(x)), (pageToken, pageSize) => this._getDetailedDeliveryReceiptsPaginator({ pageToken, pageSize }), response.body.meta.previous_token, response.body.meta.next_token);
    }
}
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync('string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Message.prototype, "updateBody", null);
__decorate([
    twilio_sdk_type_validator_1.validateTypesAsync(['string', 'number', 'boolean', 'object', twilio_sdk_type_validator_1.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Message.prototype, "updateAttributes", null);
exports.Message = Message;
/**
 * Fired when the Message's properties or body has been updated.
 * @event Message#updated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
