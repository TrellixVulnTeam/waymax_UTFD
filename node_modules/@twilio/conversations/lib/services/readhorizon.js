"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sessionerror_1 = require("../sessionerror");
class ConsumptionReportRequest {
}
class ConsumptionReportEntry {
}
class ReadHorizonPromise {
}
/**
 * @classdesc Provides read horizon management functionality
 */
class ReadHorizon {
    constructor(services) {
        this.services = services;
        this.readHorizonRequests = new Map();
        this.readHorizonUpdateTimer = null;
    }
    getReportInterval() {
        return this.services.session.getConsumptionReportInterval().then(seconds => seconds * 1000);
    }
    delayedSendReadHorizon(delay) {
        if (this.readHorizonUpdateTimer !== null) {
            return;
        }
        this.sendConsumptionReport(true);
        this.readHorizonUpdateTimer = setTimeout(() => {
            this.sendConsumptionReport(false);
        }, delay);
    }
    sendConsumptionReport(keepTimer) {
        let reports = [];
        let promises = new Map();
        this.readHorizonRequests.forEach((request, conversationSid) => {
            reports.push(request.entry);
            promises.set(conversationSid, request.promises);
        });
        if (reports.length > 0) {
            this.services.session.addCommand('consumptionReportV2', { report: reports })
                .then(response => this.processConsumptionReportResponse(response, promises))
                .catch(err => this.processConsumptionReportError(err, promises));
        }
        if (!keepTimer) {
            this.readHorizonUpdateTimer = null;
        }
        this.readHorizonRequests.clear();
    }
    processConsumptionReportResponse(response, promises) {
        if (response && response.report && Array.isArray(response.report) && response.report.length > 0) {
            response.report.forEach(entry => {
                let responseEntry = entry;
                if (promises.has(responseEntry.channelSid)) {
                    let unreadMessagesCount = null;
                    if ((typeof responseEntry.unreadMessagesCount !== 'undefined') && responseEntry.unreadMessagesCount != null) {
                        unreadMessagesCount = responseEntry.unreadMessagesCount;
                    }
                    promises.get(responseEntry.channelSid).forEach(promise => promise.resolve(unreadMessagesCount));
                    promises.delete(responseEntry.channelSid);
                }
            });
        }
        this.processConsumptionReportError(new sessionerror_1.SessionError('Error while setting LastReadMessageIndex', null), promises);
    }
    processConsumptionReportError(err, promises) {
        promises.forEach(conversationPromises => conversationPromises.forEach(promise => promise.reject(err)));
    }
    /**
     * Updates read horizon value without any checks
     */
    updateLastReadMessageIndexForConversation(conversationSid, messageIdx) {
        return new Promise((resolve, reject) => {
            this.addPendingConsumptionHorizonRequest(conversationSid, { channelSid: conversationSid, messageIdx }, { resolve, reject });
            this.getReportInterval().then(delay => this.delayedSendReadHorizon(delay));
        });
    }
    /**
     * Move read horizon forward
     */
    advanceLastReadMessageIndexForConversation(conversationSid, messageIdx, currentConversationLastReadIndex) {
        let currentHorizon = this.readHorizonRequests.get(conversationSid);
        return new Promise((resolve, reject) => {
            if (currentHorizon && currentHorizon.entry) {
                if (currentHorizon.entry.messageIdx >= messageIdx) {
                    this.addPendingConsumptionHorizonRequest(conversationSid, currentHorizon.entry, { resolve, reject });
                }
                else {
                    this.addPendingConsumptionHorizonRequest(conversationSid, { channelSid: conversationSid, messageIdx }, { resolve, reject });
                }
            }
            else {
                if ((currentConversationLastReadIndex !== null) && messageIdx < currentConversationLastReadIndex) {
                    this.addPendingConsumptionHorizonRequest(conversationSid, { channelSid: conversationSid, messageIdx: currentConversationLastReadIndex }, { resolve, reject });
                }
                else {
                    this.addPendingConsumptionHorizonRequest(conversationSid, { channelSid: conversationSid, messageIdx }, { resolve, reject });
                }
            }
            this.getReportInterval().then(delay => this.delayedSendReadHorizon(delay));
        });
    }
    addPendingConsumptionHorizonRequest(conversationSid, entry, promise) {
        if (this.readHorizonRequests.has(conversationSid)) {
            let request = this.readHorizonRequests.get(conversationSid);
            request.entry = entry;
            request.promises.push(promise);
        }
        else {
            this.readHorizonRequests.set(conversationSid, { entry, promises: [promise] });
        }
    }
}
exports.ReadHorizon = ReadHorizon;
