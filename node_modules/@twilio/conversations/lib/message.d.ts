/// <reference types="node" />
import { EventEmitter } from 'events';
import { Conversation } from './conversation';
import { Session } from './session';
import { McsClient } from 'twilio-mcs-client';
import { Media } from './media';
import { Participant } from './participant';
import { AggregatedDeliveryReceipt } from './aggregateddeliveryreceipt';
import { Network } from './services/network';
import { DetailedDeliveryReceipt } from './detaileddeliveryreceipt';
declare namespace Message {
    type Type = 'text' | 'media';
}
export interface MessageServices {
    session: Session;
    mcsClient: McsClient;
    network: Network;
}
declare namespace Message {
    type UpdateReason = 'body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author' | 'deliveryReceipt' | 'subject';
    interface UpdatedEventArgs {
        message: Message;
        updateReasons: Message.UpdateReason[];
    }
}
/**
 * @classdesc A Message represents a Message in a Conversation.
 * @property {String} author - The name of the user that sent Message
 * @property {String|null} subject - Message subject. Used only in email conversations
 * @property {String} body - The body of the Message. Is null if Message is Media Message
 * @property {any} attributes - Message custom attributes
 * @property {Conversation} conversation - Conversation Message belongs to
 * @property {Date} dateCreated - When Message was created
 * @property {Date} dateUpdated - When Message was updated
 * @property {Number} index - Index of Message in the Conversation's messages list
 *  By design of the conversations system the message indices may have arbitrary gaps between them,
 *  that does not necessarily mean they were deleted or otherwise modified - just that
 *  messages may have non-contiguous indices even if they are sent immediately one after another.
 *
 *  Trying to use indices for some calculations is going to be unreliable.
 *
 *  To calculate the number of unread messages it is better to use the read horizon API.
 *  See {@link Conversation#getUnreadMessagesCount} for details.
 *
 * @property {String} lastUpdatedBy - Identity of the last user that updated Message
 * @property {Media} media - Contains Media information (if present)
 * @property {String} participantSid - Authoring Participant's server-assigned unique identifier
 * @property {String} sid - The server-assigned unique identifier for Message
 * @property {'text' | 'media'} type - Type of message: 'text' or 'media'
 * @property {AggregatedDeliveryReceipt | null} aggregatedDeliveryReceipt - Aggregated information about
 *   Message delivery statuses across all {@link Participant}s of a {@link Conversation}.
 * @fires Message#updated
 */
declare class Message extends EventEmitter {
    readonly conversation: Conversation;
    private services;
    private state;
    /**
     * The update reason for <code>updated</code> event emitted on Message
     * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author' |
     *   'deliveryReceipt' | 'subject')} Message#UpdateReason
     */
    constructor(conversation: Conversation, services: MessageServices, index: number, data: any);
    get sid(): string;
    get author(): string;
    get subject(): string | null;
    get body(): string;
    get dateUpdated(): Date;
    get index(): number;
    get lastUpdatedBy(): string;
    get dateCreated(): Date;
    get attributes(): Object;
    get type(): Message.Type;
    get media(): Media;
    get participantSid(): string;
    get aggregatedDeliveryReceipt(): AggregatedDeliveryReceipt | null;
    _update(data: any): void;
    /**
     * Get Participant who is author of the Message
     * @returns {Promise<Participant>}
     */
    getParticipant(): Promise<Participant>;
    /**
     * Get delivery receipts of the message
     * @returns {Promise<DetailedDeliveryReceipt[]>}
     */
    getDetailedDeliveryReceipts(): Promise<DetailedDeliveryReceipt[]>;
    /**
     * Remove the Message.
     * @returns {Promise<Message>}
     */
    remove(): Promise<Message>;
    /**
     * Edit message body.
     * @param {String} body - new body of Message.
     * @returns {Promise<Message>}
     */
    updateBody(body: string): Promise<Message>;
    /**
     * Edit message attributes.
     * @param {any} attributes new attributes for Message.
     * @returns {Promise<Message>}
     */
    updateAttributes(attributes: any): Promise<Message>;
    private _getDetailedDeliveryReceiptsPaginator;
}
export { Message };
/**
 * Fired when the Message's properties or body has been updated.
 * @event Message#updated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
